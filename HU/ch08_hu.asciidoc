[[ch8]]
== Bányászat és konszenzus

[[mining]]
=== Bevezetés

((("konszenzus", id="ix_ch08-asciidoc0", range="startofrange")))((("bányászat", id="ix_ch08-asciidoc1", range="startofrange")))((("bányászok")))A bányászat az a folyamat, amely a pénzkészletet új bitcoinokkal bővíti. A bányászat emellett védi a bitcoin rendszert a csalásoktól vagy ugyanannak a bitcoin összegnek a többszöri elköltésétől, azaz az ún. kettős költéstől is. A bányászok felfolgozó kapacitást biztosítanak a bitcoin hálózatnak, ezért cserébe bitcoinokat kaphatnak jutalomul. 

 A bányászok ellenőrzik az új tranzakciókat és a globális főkönyvbe rögzítik őket. Minden 10 percben egy új blokk kerül „kibányászásra”, amely az utolsó blokk kibányászása óta előfordult tranzakciókat tartalmazza, vagyis a blokkláncot ezekkel a tranzakciókkal bővíti. A blokkba foglalt, és a blokklánchoz hozzáadott tranzakciók „megerősített” tranzakciók. A megerősítés teszi lehetővé az új bitcoin tulajdonosok számára, hogy elköltsék az ilyen tranzakciókban kapott bitcoinjaikat. 

A bányászok kétféle jutalmat kapnak a bányászatért: az új blokkokkal létrejövő új érméket, és a blokkban lévő tranzakciók tranzakciós díjait. Ahhoz, hogy megkaphassák ezt a jutalmat, a bányászoknak egy kriptográfiai hash algoritmussal kapcsolatos bonyolult matematikai problémát kell megoldaniuk. A probléma megoldása, az ún. munkabizonyíték (Proof-of-Work) beépül az új blokkba, és bizonyítékul szolgál arra nézve, hogy a bányász jelentős számítási munkát végzett. A bitcoin biztonságát az egymással versenyző bányászok alapozzák meg, akik a munkabizonyíték előállítási feladat megoldása révén jutalomhoz és a tranzakciók blokkláncban történő rögzítésének a jogához jutnak. 

((("új érmék előállítása")))Az új érmék előállításának folyamatát azért hívjuk bányászatnak, mert a jutalom úgy lett megalkotva, hogy a nemesfémek bányászatához hasonlóan a hozadék egyre kisebb legyen. A bitcoin pénz-kibocsátása bányászattal történik, hasonlóan ahhoz, ahogy egy központi bank bankjegyek nyomtatásával új pénzt hoz létre. ((("bitcoin","kibocsájtás sebessége")))A bányászok által a blokkhoz hozzáadott új bitcoinok mennyisége kb. négy évenként (pontosabban 210 ezer blokkonként) a felére csökken. 2009 januárjában 50 bitcoin/blokk értékkel indult a folyamat, ez 2012 novemberében 25 bitcoin/blokkra csökkent. A jutalom valamikor 2016-ban fog újra feleződni, és 12.5 bitcoin lesz. Ennek a képletnek az alapján a bitcoin bányászat jutalma exponenciálisan csökkenni fog, egészen 2140-ig, amikorra az összes bitcoin (20'999'999.98 BTC) kibocsátásra kerül. 2140 után több új bitcoin már nem kerül forgalomba.

((("díjak, tranzakciós")))((("tranzakciós","díjak")))A bitcoin bányászok a tranzakciós díjakat is megkapják. Mindegyik tranzakció tartalmazhat tranzakciós díjat, a tranzakció bemenetei és kimenetei közötti különbség formájában. A győztes bitcoin bányász jut hozzá a nyertes blokk tranzakcióiban lévő „visszajáró” pénzhez. Manapság a díjak a bitcoin bányászok bevételeinek 0.5 %-át vagy még kisebb hányadát alkotják, a bevétel túlnyomó többsége az újonnan „vert” bitcoinokból származik. De ahogy a jutalom idővel csökken majd, a blokkonkénti tranzakciók száma pedig nő, úgy fog a bitcoin bányászok bevételének egyre nagyobb hányada a díjakból származni. 2140 után a bitcoin bányászok összes bevételét a tranzakciós díjak fogják jelenteni.

A „bányászat” szó kicsit félrevezető. Azáltal, hogy a nemesfémek bányászatának a képét idézi föl, a bányászatért kapott jutalmat, a blokkonként létrejövő új bitcoinokat állítja a figyelem középpontjába. Noha a bányászokat ez a jutalom mobilizálja, a bányászat elsődleges célja nem a jutalom vagy az új érmék előállítása. Ha a bányászatot csak az érmék előállítására szolgáló folyamatnak tekintjük, akkor nem szabad a folyamat eszközét (ösztönzőjét) a folyamat céljával összekevernünk. A bányászat jelenti a decentralizált elszámolóház fő folyamatát. A bányszat során kerülnek ellenőrzésre és elszámolásra a tranzakciók. A bányászat teremti meg a bitcoin rendszer biztonságát és teszi lehetővé, hogy az egész hálózatban központi szervezet nélkül létrejöjjön a konszenzus. 

A bányászat az az újítás, ami a bitcoint különlegessé teszi: ez az a decentralizált biztonsági mechanizmus, ami a peer-to-peer digitális pénz alapja. Az újonnan kibocsájtott érmékkel kapott jutalom és a tranzakciós díjak olyan ösztönzést jelentenek, amely a bányászok tetteit a hálózat biztonságával hangolja össze, és egyúttal a pénzkibocsátást is megoldja. 

Ebben a fejezetben először a bányászatot mint pénz kibocsátó mechanizmust fogjuk vizsgálni, majd megnézzük a bányászat legfontosabb funkcióját: a decentralizált konszenzus létrejöttének módját, amely megteremti a bitcoin biztonságát.

==== A bitcoin gazdaság és a pénz kibocsájtás

((("pénzkibocsájtás", id="ix_ch08-asciidoc2", range="startofrange")))((("bányászat","pénzkibocsájtás", id="ix_ch08-asciidoc3", range="startofrange")))A bitcoinokat az új blokkok létrehozása során „verik”, fix és egyre csökkenő ütemben. Az átalgosan 10 percenként létrejövő új blokkok mindegyikében teljesen új bitcoinok vannak, melyek a semmiből jönnek létre. Minden 210 ezer blokk után, azaz kb. négy évente a pénz kibocsátás mértéke 50 %-kal csökken. A hálózat működésének első négy éve során mindegyik új blokk 50 új bitcoint tartalmazott. 

2012 novemberében az új bitcoinok kibocsájtási üteme 25 bitcoin/blokkra csökkent, és valamikor 2016-ban, a 420'000-ik blokknál fog csökkenni ismét, és 12.5 bitcoin lesz. Az új érmék kibocsájtási üteme 64 „felezés” révén, exponenciálisan csökken, egészen a 13'230'000-ik blokkig (melyet valamikor 2137-ben fognak kibányászni), amikor is a jutalom eléri a legkisebb pénzegységet, az 1 satoshit. Végül a 13.44 milliomodik blokk után, kb. 2140-re a kibocsájtott bitcoinok mennyisége 2'099'999'997'690'000 satoshi, azaz kb. 21 millió bitcoin lesz. Ezt követően a blokkok már nem fognak új bitcoinokat tartalmazni, és a bányászok jutalma kizárólag a tranzakciós díjakból fog származni. A <<bitcoin_money_supply>> mutatja a forrgalomban lévő bitcoinokat az idő függvényében. Látható a kibocsájtás csökkenő üteme.

[[bitcoin_money_supply]]
.A bitcoin mennyiségét az idő függvényében egy mértanilag csökkenő pénzkibocsájtási ütem jellemzi
image::images/msbt_0801.png["BitcoinMoneySupply"]

[NOTE]
====
A kibányászott érmék száma adja a bitcoinok számának _felső határát_. A gyakorlatban a bányászoknak nem kötelező a blokk után járó teljes jutalom kibányászása. Ilyen blokkok már eddig is előfordultak, és a jövőben is lehetnek ilyenek, emiatt az össze bitcoin száma kevesebb lesz, mint az elvi határ.
====

A <<max_money>> példaprogramban kiszámítjuk a forgalomba kerülő összes bitcoin számát.

[[max_money]]
.Egy script, amely azt számítja ki, hogy összesen hány bitcoin fog forgalomba kerülni
====
[source, python]
----
include::code/max_money.py[]
----
====

A <<max_money_run>> mutatja a script futtatása során kapott kimenetet.

[[max_money_run]]
.A max_money.py script futtatása
====
[source,bash]
----
$ python max_money.py 
Az összes, valaha létrejövő BTC: 2099999997690000 Satoshi
----
====

((("infláció, ~val szembeni ellenállóképesség")))A véges és egyre csökkenő mértékű kibocsájtás egy véges pénzkészletet hoz létre, amely ellenálló az inflációval szemben. A hagyományos papírpénzekkel szemben, melyek korlátlanul nyomtathatók, a bitcoin nyomtatással soha sem lesz inflálható.

.Deflációs pénz
****
((("deflációs pénz")))A fix és egyre csökkenő pénzkibocsájtás egyik legfontosabb és legvitatottabb következménye az, hogy a pénz óhatatlanul _deflációs_ tendenciát rejt magában. A defláció az a jelenség, melynek során a pénz értéke nő, mivel a kereslet és a kínálat közötti egyensúly hiánya felhajtja a a pénz értékét (és váltási árfolyamát). Az árak deflációja, vagyis az infláció ellentéte azt jelenti, hogy a pénznek idővel egyre nagyobb lesz a vásárlóértéke.

Sok közgazdász szerint egy deflációs gazdaság katasztrófát jelent, és mindenáron el kell kerülni. Ennek az az oka, hogy a gyors defláció időszakában az emberek inkább felhalmozzák a pénzt, ahelyett hogy elköltenék, mert azt remélik, hogy az árak csökkenni fognak. Ilyen jelenség bontakozott ki Japán „Elveszett Évtizede” során, mikor a kereslet teljes összeomlása egy deflációs spirálba taszította a japán pénzt. 

A bitcoin szakértők szerint a defláció önmagában nem rossz. Szerintük a deflációt eddig azért hozták kapcsolatba a kereslet összeomlásával, mert az általunk ismert deflációra ez az egyetlen példa. A papírpénz korlátlan nyomtathatósága mellett nagyon nehéz deflációs spirálba kerülni, kivéve, ha teljesen összeomlik a kereslet és nincs pénznyomtatási hajlandóság. A bitcoin deflációját nem a kereslet összeomlása okozza, hanem az előre megjósolható kibocsájtás. 

A gyakorlatban bebizonyosodott, hogy a deflációs pénz által okozott felhalmozási ösztön árleszállításokkal legyőzhető, ha ennek mértéke nagyobb, mint a vevő felhalmozási ösztöne. Mivel az eladó szintén érdekelt a pénz felhalmozásban, a leszállított ár jelenti azt az egyensúlyi árat, amely mellett a két felhalmozási ösztön kiegyenlíti egymást. A legtöbb eladó 30%-os árleszállítással különösebb nehézségek nélkül le tudja győzni a felhalmozási ösztönt, és bevételt tud generálni. A jövő zenéje, hogy a pénz deflációs jellege valóban próblémát jelent-e, ha a deflációt nem a gyors gazdaságcsökkenés váltja ki.(((range="endofrange", startref="ix_ch08-asciidoc3")))(((range="endofrange", startref="ix_ch08-asciidoc2")))
****

=== Decentralizált konszenzus

((("consensus","decentralized")))((("decentralized consensus")))Az előző fejezetben a blokkláncot, vagyis az összes tranzakciót tartalmazó publikus globális főkönyvet vizsgáltuk, amelyet a bitcoin rendszer valamennyi résztvevője a tulajdon hiteles okmányaként fogad el. 

De hogyan lehet a hálózaton belül kölcsönös bizalom nélkül egyetlen univerzális „igazságban” megállapodni arról, hogy kinek mije van? Az összes hagyományos fizetési rendszer egy bizalmi modellen alapul, melyben egy központi szervezet nyújtja az elszámolási szolgáltatást, melynek során alapjában véve a tranzakciók ellenőrzése és elszámolása történik. A bitcoinban nincs ilyen központi szervezet, de mégis minden csomópontnak egy teljes másolata van a főkönyvről, melyben hiteles okmányként megbízhat. A blokkláncot nem egy központi szervezet hozza létre, hanem egymástól függetlenül a hálózat csomópontjai állítják össze. Valamiféleképpen a hálózat csomópontjai képesek a nem biztonságos hálózati összeköttetéseken továbbított információk alapján ugyanarra a következtetésre jutni és ugyanazt a főkönyönvi példányt összeállítani, mint a többiek. Ebben a fejezetben azt a folyamatot vizsgájuk meg, amellyel a a bitcoin hálózat központi szervezet nélkül globális konszenzust ér el.

((("Nakamoto, Satoshi")))Satoshi Nakamoto fő felfedezése a ((("emergens konszenzus")))_konszenzus kialakulásának_ decentralizált mechanizmusa volt. Ez a konszenzus nem explicit módon jön létre – nincsenek választások vagy rögzített időpillanatok, amikor konszenzus van. A közmegegyezés inább a sok ezer, egyszerű szabályokat követő, független csomópontok aszinkron kölcsönhatásai révén alakul ki. A bitcoin esetén a pénz, a tranzakciók, a pénz küldés vagy a biztonság nem valamilyen központi szervezettől függ és nem a bizalomra épül, hanem ebből a felfedezésből adódik. 

A bitcoin decentralizált konszenzusa négy folyamat kölcsönhatásának az ereményeképpen jön létre. A négy folyamat egymástól függetlenül megy végbe a hálózat csomópontjain: 

* minden egyes tranzakció egymástól független ellenőrzése. Ezt számos kritérium alapján a teljes csomópontok végzik.
* ezeknek a tranzakciónak az új blokkokban történő egyesítése. Ezt a bányász csomópontok egymástól függetlenül végzik. A bányász csomópontok a munkabizonyíték algoritmus segítségével igazolják, hogy elvégeztek bizonyos számításokat.
* az új blokk ellenőrzése és láncba szervezése, melyet az egyes csomópontok egymástól függetlenül végeznek.
* a legtöbb összesített munkabizonyíték számítást tartalmazó lánc kiválasztása. Ezt minden egyes csomópont a többitől függetlenül végzi.

A következő néhány részben megvizsgáljuk ezeket a folyamatokat, valamint megnézzük, hogy a kölcsönhatásaik hogyan teremtik meg a hálózat egészében megjelenő közmegegyezést, amellyel bármely bitcoin csomópont képes a saját hiteles, megbizható, publikus és globális főkönyvének az összeállítására.

[[tx_verification]]
=== A tranzakciók egymástól független ellenőrzése

((("konszenzus","tranzakciók független ellenőrzése")))((("tranzakciók","~ független ellenőrzése")))A <<transactions>> című fejezetben láttuk, hogy egy pénztárca az UTXO-k összegyűjtésével állítja elő a tranzakciókat. Ennek során először megadja a megfelelő zárolást feloldó scripteket, majd új kimeneteket hoz létre, melyek egy új tulajdonoshoz vannak hozzárendelve. Az így előálló tranzakciót ezután elküldi a bitcoin hálózat szomszédos csompontjainak, hogy a tranzakció az egész bitcoin hálózatban szétterjedhessen. 

Mielőtt azonban egy bitcoin csomópont továbbítaná a tranzakciókat a szomszédainak, először ellenőrzi őket. Ez biztosítja, hogy csak érvényes tranzakciók terjedjenek tova a hálózatban, az érvénytelen tranzakciókat pedig már az első csomópont elvesse. 

((("kialakuló konszenzus","kritériumai")))((("tranzakciók","ellenőrzési kritériumai")))A csomópontok az egyes tranzakciótat kritériumok hosszú sora alapján ellenőrzik:

* helyes-e a tranzakció szintaxisa és adatstruktúrája
* sem a bemenetek, sem a kimenetek listája nem lehet üres
* a tranzakció mérete bájtokban kisebb-e a +MAX_BLOCK_SIZE+-nál
* az egyes kimenetek értéke, valamint ezek összege a megengedett tartományon belül van-e (kevesebb-e, mint 21 M érme, és több-e, mint 0)
* semelyik bemenet hash-e sem lehet 0, N=-1 (a coinbase tranzakciókat nem kell továbbküldeni)
* az +nLockTime+ kisebb vagy egyenlő-e +INT_MAX+-nál
* a tranzakció mérete bájtokban nagyobb vagy egyenlő-e 100-nál
* a tranzakcióban lévő aláírási műveletek száma kevesebb-e, mint az aláírások max. számára vonatkozó határ
* a zárolást feloldó script (+scriptSig+) csak számokat helyezhet a veremre, a zároló scriptnek (+scriptPubkey+) pedig meg kell felelnie az +isStandard+ formátumoknak (itt történik a „nem szabványos” tranzakciók elvetése)
* a memória pool-ban vagy a fő ág egy blokkjában kell legyen egy ennek megfelelő tranzakció
* minden egyes bemenetre: ha a hivatkozott kimenetek léteznek a memória poolban lévő bármelyik másik tranzakcióban, akkor a tranzakció elvetése
* minden egyes bemenetre: annak az ellenőrzése, hogy létezik-e a fő ágban vagy a tranzakció poolban a hivatkozott kimeneti tranzakció. Ha a kimeneti tranzakció bármelyik bemenetnél hiányzik, akkor egy árva tranzakcióról van szó. A tranzakciót az árva tranzakciók listájához adja hozzá, ha a poolban még nincs meg az illeszkedő tranzakció
* minden egyes bemenetre: ha a hivatkozott kimeneti tranzakció egy coinbase kimenet, akkor van-e már legalább +COINBASE_MATURITY+ (100) megerősítése 
* minden egyes bemenetre: a hivatkozott kimenet létezik-e és elköltetlen-e
* a hivatkozott kimeneti tranzakciók alapján a bemeneti értékük megállapítása, és annak az ellenőrzése, hogy mindegyik bemeneti érték, valamint az összegük is a megengedett értéktartományban van-e (21 M érménél kevesebb, 0-nál több)
* a tranzakció elvetése, ha a bemeneti értéke összege < a kimeneti értékek összege
* a tranzakció elvetése, ha a tranzakciós díj túl kicsi ahhoz, hogy a tranzakció bekerülhessen egy üres blokkba
*  minden egyes bemenetre: a zárolást feloldó script és a neki megfelelő kimeneti zároló script megefelel-e egymásnak

Ezek a feltételek a bitcoin referencia kliens következő függvényeiben vannak részeletsen leírva: +AcceptToMemoryPool+, +CheckTransaction+, és +CheckInputs+. A feltételek idővel változhatnak, pl. ha újfajta Dos szolgáltatás megtagadási támadások kezelésére van szükség, vagy arra, hogy a szabályok lazítása révén többféle tranzakció típus legyen kezelhető. 

Mivel a többi csomóponttól függetlenül mindegyik csomópont ellenőrzi a tranazakciókat azok beérkezésekor, és a továbbításuk előtt, mindegyik csomópont felépíti az érvényes (de még nem megerősített) új tranzakciók készletét, az ú.n. _tranzakció pool_-t, vagy másképpen _memória pool_-t vagy _mempool_-t.

=== Bányász csomópontok

((("bányászat","csomópontok")))((("csomópontok","bányászat")))A bitcoin hálózat bizonyos csomópontjai speciális csomópontok, az ún. _bányászok_. Az <<ch01_intro_what_is_bitcoin>> fejezetben bemutattuk Jinget, a bitcoin bányászt, aki Sanghajban számítástechnikát tanul. Jing úgy jut bitcoinokhoz, hogy egy „bányász platformot” üzemeltet, amely egy bitcoin bányászatra szolgáló speciális számítógép hardver. Jing speciális bányász hardvere összeköttetésben áll egy teljes bitcoin csomópontot futtató szerverrel. Jingtől eltérően némelyik bányász teljes csomópont nélkül bányászik, amint azt a <<mining_pools>> részben látni fogjuk. Jing csomópontja a hálózat többi csomópontjához hasonlóan megkapja és továbbítja a hálózat megerősítetlen tranzakcióit. Jing csomópontja azonban új blokkokba is egyesíti ezeket a tranzakciókat.
    
Jing csomópontja a többi csomóponthoz hasonlóan szintén észleli a bitcoin hálózatot belül továbbított új blokkokat.  De egy új blokk érkezése a bányász csomópont számára speciális jelentőségű. A bányászok közötti versengést lényegében az új blokk szétterjedése állítja le, mert ez felel meg a győztes kihirdetésének. Egy bányász számára egy új blokk érekezése azt jelenti, hogy valaki más nyerte meg a versenyt, ő pedig veszített. De az egyik versenyforduló vége egyúttal a következő forduló kezdete. Az új blokk nem csak egy kockás zászló, amely a verseny végét jelzi, hanem egy startpisztoly is, mely a következő blokkért folyó versenyt indítja.

=== A tranzakciók blokkokba gyűjtése

((("blokkláncok","létrejötte blokkokból")))((("blokkok","összeállítása")))((("blokkok","jelöltek, összeállítása")))((("jelölt blokkok","összeállítása")))((("bányászat","tranzakciók összeállítása")))((("tranzakció pool-ok","blokkok hozzáadása")))((("tranzakciók","blokkokba rendezése")))A bitcoin csomópontokban a tranzakciók az ellenőrzés után bekerülnek a _memória pool_-okba, másképpen _tranzakció készlet_ekbe. A tranzakciók itt várakoznak arra, hogy bekerüljenek egy blokkba (kibányásszák őket). Jing csomópontja a többi csomóponthoz hasonlóan összegyűjti, ellenőrzi, és továbbítja az új tranzakciókat. De a többi csomóponttól eltérően Jing csomópontja ezekből a tranzakciókból egy _blokk jelöltet_ is létrehoz.

Kövessük a annak a blokknak az útját, amely akkor keletkezett, amikor Alice egy csésze kávét vett Bob kávézójában (lásd az <<cup_of_coffee>> részt). Alice tranzakciója a 277'316-ik blokkba lett befoglalva. A fejezetben szereplő fogalmak szemléltetése érdekében tegyük fel, hogy a blokkot Jing bányagépe bányászta ki, és kövessük Alice tranzakcióját, amint részévé válik ennek az új blokknak.

Jing bányász csomópontja egy helyi példányt tart fönn a blokkláncból, vagyis azokból a blokkokból, melyek bitcoin rendszer kezdete, 2009 óta képződtek. Mikor Alice megvette a csésze kávét, Jing csomópontja már egészen a 277'314-ik blokkig összeállította a láncot. Jing csomópontja figyelte a tranzakciókat, megpróbált előállítani egy új blokkot, és egyúttal figyelte a többi csomópont által előállított blokkokat is. Miközben Jing csomópontja bányászott, megjött a 277'315-ik blokk a bitcoin hálózattól. Az új blokk érkezése jelezte a 277'315-ik blokkért történő versengés végét, és a 277'316-ik előállításáért folytatott verseny kezdetét.  

Az előző 10 percben, míg Jing csomópontja a 277'315-ik blokk megoldását kereste, az új blokk előállításának előkészületeként tranzakciókat is gyűjtött. Mostanra már pár száz tranzakció gyűlt össze a memóriában. Amikor Jing csomópontja megkapta a 277'315-ik blokkot és ellenőrizte azt, a memóriában lévő tranzakciókat is ellenőrizte, és eltávolította közülük azokat, melyek szerepeltek a 277'315- blokkban. A memóriában maradt tranzakciók megerősítetlenek, és arra várnak, hogy egy új blokkba foglalják őket. 

Jing csomópontja egy új üres blokkot állít elő, a 277'316-ik blokkot. Ez a blokk csak egy létrehozandó jelölt, amely még nem érvényes, mivel nem tartalmaz érvényes munkabizonyítékot. A blokk csak akkor válik érvényessé, ha a bányásznak sikerül egy megoldást találnia a munkabizonyíték algoritmusra .

==== Tranzakció életkor, díjak és prioritás

((("jelölt blokkok","tranzakciók éltekora", id="ix_ch08-asciidoc4", range="startofrange")))((("jelölt blokkok","tranzakciók prioritása", id="ix_ch08-asciidoc5", range="startofrange")))((("jelölt blokkok","tranzakciós díjak", id="ix_ch08-asciidoc6", range="startofrange")))((("díjak, tranzakciós", id="ix_ch08-asciidoc7", range="startofrange")))((("tranzakciók","életkora", id="ix_ch08-asciidoc8", range="startofrange")))((("tranzakciók","prioritása", id="ix_ch08-asciidoc9", range="startofrange")))Jing bitcoin csomópontja kiszámítja az összes, memóriában lévő tranzakció prioritását, és a létrehozandó blokk jelölthöz először a legmagasabb prioritású tranzakciókat adja hozzá. A tranzakciók prioritása a bemeneteikben szereplő UTXO-k „életkorától” függ. Ez lehetővé teszi, hogy a régi és nagy értékű bemenetek elsőbbséget élvezzenek az újabb és kisebb bemenetekkel szemben. Az elsőbbséget élvező/priorizált tranzakciók díj nélkül küldhetők, ha elég hely van a blokkban. 

A tranzakció prioritása úgy számítható ki, hogy összeadjuk az egyes bemenetek értékének és életkorának szorzatait, és az összeget elosztjuk a tranzakció teljes méretével:

----
Prioritás = Összeg (Bemenet_értéke * Bemenet_életkora) / Tranzakció_méret
----

A fenti egyenletben a bemenet értéke alap egységekben, satoshi-ban (1/100M bitcoinban) van megadva. Az UTXO életkora az UTXO-nak a blokkláncban történő rögzítése óta képződött blokkok számával egyenlő. Az életkor azt méri, hogy milyen „mélyen” van a blokk a blokkláncban. A tranzakció mérete bájtokban van megadva.

Egy tranzakció akkor számít „magas prioritásúnak”, ha a prioritása nagyobb, mint 57'600'000, ami annak felel meg meg, mint ha 1 bitcoin (100M satoshi), melynek életkora 1 nap (144 blokk) egy 250 bájt méretű tranzakcióban szerepelne.

----
Magas_prioritás > 100'000'000 satoshi * 144 blokk / 250 bájt = 57'600'000
----

A blokk első 50 kilobájtja a magas prioritású tranzakciók számára van fenntartva. Jing csomópontja kitölti az első 50 kilobájtot, és ebben a díjtól függetlenül a legmagasabb prioritású tranzakciókat helyezi el először. Ennek megfelelően a magas prioritású tranzakciók akkor is feldolgozásra kerülnek, ha a bennük szereplő tranzakciós díj nulla.

Ezután Jing csomópontja a blokk maradék részét azokkal a tranzakciókkal tölti fel, melyek legalább a minimális tranzakciós díjat tartalmazzák, elsőbbségben részesítve azokat, melyeknél egy kilobájtra vonatkoztatva a legmagasabb a tranzakciós díj. A feltöltés egészen a max. blokkméretig (a kódban +MAX_BLOCK_SIZE+) tart.

Ha marad még hely a blokkban, akkor Jing bányász csomópontja a maradék helyet tranzakciós díj nélküli tranzakciókkal tölti fel. Némelyik bányász a tranzakciós díj nélküli tranzakciókat „ahogy esik, úgy puffan” módon kezeli. Más bányászok viszont akár teljesen ki is hagyhatják a létrehozandó blokk jelöltből ezeket a tranzakciókat. 

A blokk felöltése után a memóriában maradó tranzakciók a következő blokkba kerülhetnek be. A memóriában maradó tranzakció bemenetei „öregebbekké” válnak, mivel az általuk elköltött UTXO az új blokk miatt mélyebbre került a blokkláncban. Mivel a tranzakció prioritása függ a bemeneteinek az életkorától, a memóriában maradó tranzakciók egyre régebbiek lesznek, és emiatt nő a prioritásuk. Végül a tranzakciós díjat nem tartalmazó tranzakciók is elég magas prioritásúvá válhatnak ahhoz, hogy díjtalanul befoglalásra kerülhessenek egy blokkba. 

((("tranzakciók","lejárat hiánya")))A bitcoin tranzakcióknak nincs lejárati idejük. Egy jelenleg érvényes tranzakció az idők végezetéig érvényes marad. Mivel azonban a tranzakciót a hálózat csak egyszer továbbítja, csak addig marad fenn, amíg benne van egy bányász csomópont memóriájában. Ha a bányász csomópontot újraindítják, a memóriájában lévő tartalom törlődik, mivel a memória csak egy átmeneti, nem tartós tárolási forma. Ha a hálózat egy érvényes tranzakciót küldött szét, de a tranzakció nem hajtódik végre, akkor ennek az lehet az oka, hogy már nincs egyetlen bányász memóriájába sem. A pénztárca szoftverek ilyen esetben vagy változatlanul újraküldik a tranzakciót, vagy magasabb tranzakciós díjjal ismét előállítják és elküldik őket, amíg végül ésszerű idő alatt meg nem történik a végrehajtásuk.

Mikor Jing csomópontja összeszedte a memóriában lévő tranzakciókat, a jövendő blokk 418 tranzakciót tartalmazott, és a tranzakciós díj összesen 0.09094928 bitcoin volt. A blokkláncban a <block277316>>  blokk a Bitcoin Core kliens parancssori felületével a következőképpen nézhető meg:(((range="endofrange", startref="ix_ch08-asciidoc9")))(((range="endofrange", startref="ix_ch08-asciidoc8")))(((range="endofrange", startref="ix_ch08-asciidoc7")))(((range="endofrange", startref="ix_ch08-asciidoc6")))(((range="endofrange", startref="ix_ch08-asciidoc5")))(((range="endofrange", startref="ix_ch08-asciidoc4")))
====
[source,bash]
----
$ bitcoin-cli getblockhash 2773160000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4

$ bitcoin-cli getblock 0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4
----
====
[[block277316]]
.Block 277,316
====
[source,json]
----
{
    "hash" : "0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4",
    "confirmations" : 35561,
    "size" : 218629,
    "height" : 277316,
    "version" : 2,
    "merkleroot" : "c91c008c26e50763e9f548bb8b2fc323735f73577effbc55502c51eb4cc7cf2e",
    "tx" : [
        "d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f",
        "b268b45c59b39d759614757718b9918caf0ba9d97c56f3b91956ff877c503fbe",

        ... 417 további tranzakció ...

       ],
    "time" : 1388185914,
    "nonce" : 924591752,
    "bits" : "1903a30c",
    "difficulty" : 1180923195.25802612,
    "chainwork" : "000000000000000000000000000000000000000000000934695e92aaf53afa1a",
    "previousblockhash" : "0000000000000002a7bbd25a417c0374cc55261021e8a9ca74442b01284f0569",
    "nextblockhash" : "000000000000000010236c269dd6ed714dd5db39d36b33959079d78dfd431ba7"
}
----
====

==== A generáló tranzakció

((("coinbase tranzakció", id="ix_ch08-asciidoc10", range="startofrange")))A blokk első tranzakciója egy különleges tranzakció, melyet _generáló tranzakciónak_ vagy _coinbase tranzakciónak_ hívnak. Ezt a tranzakciót Jing csomópontja hozza létre, és a bányászatért járó jutalmat tartalmazza. Jing csomópontja a generáló tranzakciót a saját pénztárcájába történő kifizetésként hozza létre: „Kifizetés Jing címére 25.09094928 bitcoin értékben”. A blokk kibányászásáért kapott összes jutalmat a coinbase jutalom (25 új bitcoin) és a blokkba befoglalt tranzakciók tranzakciós díjak (0.09094928) összege adja. 


====
----
$ bitcoin-cli getrawtransaction d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f 1
----
====

[[generation_tx_example]]
.Generáló tranzakció
====
[source,json]
----
{
    "hex" : "01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff0f03443b0403858402062f503253482fffffffff0110c08d9500000000232102aa970c592640d19de03ff6f329d6fd2eecb023263b9ba5d1b81c29b523da8b21ac00000000",
    "txid" : "d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f",
    "version" : 1,
    "locktime" : 0,
    "vin" : [
        {
            "coinbase" : "03443b0403858402062f503253482f",
            "sequence" : 4294967295
        }
    ],
    "vout" : [
        {
            "value" : 25.09094928,
            "n" : 0,
            "scriptPubKey" : {
                "asm" : "02aa970c592640d19de03ff6f329d6fd2eecb023263b9ba5d1b81c29b523da8b21OP_CHECKSIG",
                "hex" : "2102aa970c592640d19de03ff6f329d6fd2eecb023263b9ba5d1b81c29b523da8b21ac",
                "reqSigs" : 1,
                "type" : "pubkey",
                "addresses" : [
                    "1MxTkeEP2PmHSMze5tUZ1hAV3YTKu2Gh1N"
                ]
            }
        }
    ],
    "blockhash" : "0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4",
    "confirmations" : 35566,
    "time" : 1388185914,
    "blocktime" : 1388185914
}
----
====

A szabályos tranzakciókkal ellentétben a generáló tranzakciók a bemenetükön nem fogyasztanak (nem költenek el) UTXO-kat. Csak egy bemenetük van, a _coinbase_, amely a semmiből állít elő új bitcoinokat. A generáló tranzakciónak egy kimenete van, melyben a bányász saját bitcoin címére történő kifizetés áll. A generáló tranzakció kimenete 25.09094928 bitcoint küld a bányász bitcoin címére, ebben az esetben az +1MxTkeEP2PmHSMze5tUZ1hAV3YTKu2Gh1N+ címre. 

==== A coinbase jutalom és tranzakciós díjak

((("coinbase adatok","díjak és")))((("coinbase jutalom, kiszámítása")))((("díjak, tranzakcióké","kiszámítása")))((("díjak, tranzakciós","generáló tranzakciók és")))((("generáló tranzakciók","coinbase jutalmak és")))((("generáló tranzakciók","díjak és")))A generáló tranzakció előállításához Jing csomópontjának először ki kell számítania a teljes tranzakciós díjat. Ehhez a blokkban szereplő 418 tranzakció összes bemenetének összegéből le kell vonnia a 418 tranzakció kimeneteinek összegét:

----
Teljes_díj = Összeg(Bemenetek) – Összeg(Kimenetek)
----

A 277'316-ik blokkban a tranzakciós díj 0.09094928 bitcoin volt. 

Ezután Jing csomópontja kiszámítja a blokkért járó jutalmat. A jutalom a blokk magasságától függ, kezdetben 50 bitcoin volt, és minden 210'000 blokk után feleződik. Mivel ennek a blokknak a magassága 277'316, 25 bitcoina a jutalom. 

A számítás a Bitcoin Core kliens +GetBlockValue+ függvényében látható, amint azt a <<getblockvalue_source>> mutatja:

[[getblockvalue_source]]
.A blokk jutalom kiszámítása – +GetBlockValue+ függvény, Bitcoin Core kliens, main.cpp, 1305. sor
====
[source, cpp]
----
int64_t GetBlockValue(int nHeight, int64_t nFees)
{
    int64_t nSubsidy = 50 * COIN;
    int halvings = nHeight / Params().SubsidyHalvingInterval();

    // Force block reward to zero when right shift is undefined.
    if (halvings >= 64)
        return nFees;

    // Subsidy is cut in half every 210,000 blocks which will occur approximately every 4 years.
    nSubsidy >>= halvings;

    return nSubsidy + nFees;
}
----
====

A kezdeti támogatás satoshiban az 50 és a +COIN+ konstans (100,000,000 satoshi) szorzata. A kezdeti jutalmat (+nSubsidy+) ez állítja be 5 milliárd satoshira. 

((("felezések, kiszámítása")))Ezt követően a függvény kiszámítja, hogy hány darab +feleződés+ történt, mégpedig úgy, hogy az aktuális blokk magasságát elosztja a felezési intervallummal (+SubsidyHalvingInterval+). A 277'316-ik blokk esetében az eredmény 1. 

A felezések értéke max. 64 lehet, emiatt 64-nél több felezés esetén a kód nulla jutalmat ad (csak a tranzakciós díjat adja vissza).

Ezután a függvény minden egyes felezésnek megfelelően jobbra léptetéssel 2-vel osztja a jutalmat (+nSubsidy+) . A 277'316-ik blokk esetében ez azt jelenti, hogy az 5 milliárd satoshis jutalmat egyszer lépteti jobbra (egy felezés van), az eredmény pedig 2.5 milliárd satoshi, vagyis 25 bitcoin. A 2-vel való osztás azért a bináris jobbra léptetéssel történik, mert ez hatékonyabb, mint egy egésszel vagy valós számmal történő osztás. 

Végül a coinbase jutalmat (+nSubsidy+) összeadja a tranzakciós díjjal (+nFees+), és ezt az összeget adja vissza eredményként. 

==== A generáló tranzakció felépítése

((("generáló tranzakció","szerkezete")))Ezen számítások után Jing csomópontja előállítja a generáló tranzakciót, amellyel kifizet magának 25.09094928 bitcoint.

Amint azt a <<generation_tx_example>> mutatja, ennek a tranzakciónak különleges formátuma van. A tranzakció bemenetén nem az elkölthető, előző UTXO-k vannak megadva, hanem egy „coinbase” bemenetet. A tranzakciós bemeneteket a  <<tx_in_structure>> részben vizsgáltuk meg. Hasonlítsunk össze egy szokásos tranzakció bemenetet a generáló tranzakció bemenetével. Egy szokásos tranzakció szerkezetét a <<table_8-1>> mutatja, míg a <<table_8-2>> a generáló tranzakció bemeneteinek a szerkezetét mutatja.

[[table_8-1]]
.Egy „közönséges” tranzakció egyik bemenetének szerkezete 
[options="header"]
|=======
|Méret | Mező | Leírás
| 32 bájt | Tranzakció hash | Mutató arra a tranzakcióra, amely az elköltendő UTXO-t tartalmazza
| 4 bájt | Output Index | Az elköltendő UTXO indexe, az első 0
| 1-9 bájt (VarInt) | A zárolást megszüntető script mérete | A zárolást megszüntető script mérete bájtokban
| Változó | A zárolást megszüntető script | Az UTXO-t zároló script feltételeit kielégítő script
| 4 bájt | Sorszám | Tx-helyettesítő lehetőség, Jelenleg letiltva, 0xFFFFFFFF
|=======

[[table_8-2]]
.A generáló tranzakció bemenetének a szerkezete 
[options="header"]
|=======
|Méret | Mező | Leírás
| 32 bájt | Tranzakció hash | Az összes bit nulla: nem hivatkozik tranzakció hash-re
| 4 bájt | Output Index | Az összes bit egy: 0xFFFFFFFF
| 1-9 bájt (VarInt) | Coinbase adat méret | Coinbase adathossz, 2 és 100 bájt között
| Változó | Coinbase adat | Tetszőleges adat, a v2 blokkokban az extra nonce-t és a bányász cimkéket tartalmazza, a blokk magassággal kell kezdődnie
a v2 blokkokban a blokk magassággal kell kezdődnie
| 4 bájt | Sorszám | 0xFFFFFFFF
|=======

A generáló tranzakcióban az első két mező olyan értékeket tartalmaz, amely nem UTXO hivatkozásnak felel meg. A „Tranzakció hash” helyett az első mező mind a 32 bájtja nullával van feltöltve. Az „Output index” 4 bájtja 0xFF (255). Az „Zárolást megszűntető script” helyén a coinbase adat található, amely a bányászok által használt adatmező. 

==== Coinbase adatok

((("coinbase adatok", id="ix_ch08-asciidoc11", range="startofrange")))((("generáló tranzakció","coinbase adatok", id="ix_ch08-asciidoc12", range="startofrange")))((("zárolást feloldó scriptek","generáló tranzakciók és")))A generáló tranzakcióknak nincs zárolást feloldó script (ún. +scriptSig+) mezőjük, hanem a mező coinbase adatokat tartalmaz, melyek hossza 2 és 100 bájt között van. Az első néhány bájt kivételével a coinbase adatok a bányász által tetszőlegesen használhatók. 

Például a genezis blokkban Satoshi Nakamoto ezt a szöveget helyezte el a coinbase adatmezőbe: „The Times 03/Jan/2009 Chancellor on brink of second bailout for banks” („The Times, 2009. jan. 3., A pénzügyminiszter hajlik a bankok második kimentésére”). Ily módon a mezőt a dátum bizonyítására és egyúttal egy üzenet továbbítására használta. Jelenleg a bányászok a coinbase adatként adják meg az extra nonce értékét, amint azt a következőkben látni fogjuk. 

A coinbase első néhány bájtja korábban tetszőleges lehetett, de ez most már nem így van. A BIP0034 (Bitcioin Improvement Proposal 34) szerint a 2. verziójú blokkoknál (amelyeknél a verzió mező 2-re van állítva) a coinbase mező elején a blokk magasságot kell megadni egy „push” script utasítással. 

A 277'316. blokkban azt látjuk, hogy a  <<generation_tx_example>> coinbase mezőjében (amely a tranzakciós bemenet „Zárolást megszüntető scriptje” vagy +scriptSig+-je) a +03443b0403858402062f503253482f+ hexadecimális szám áll. Dekódoljuk ezt az értéket! 

Az első bájt, a +03+ arra utasítja a script végrehajtó mechanizmust, hogy a következő 3 bájtot helyezze a script vermére (lásd a <<tx_script_ops_table_pushdata>> részt). A következő 3 bájt, a +0x443b04+ a blokk magasság, ahol a legkisebb helyiértékű bájt áll legelől. A bájtok sorrendjének megcserélése után +0x043b44+ lesz az eredmény, ami decimálisan 277'316. 

A következő néhány hexadecimális számjegy (+03858402062+) az _extra nonce_-t kódolja (lásd <<extra_nonce>>), amely a megfelelő munkabizonyíték előállításához használt véletlen érték.

A coinbase adat utolsó része (+2f503253482f+) a +/P2SH/+ string ASCII kódja, ami azt jelzi, hogy a blokkot kibányászó csomópont támogatja a BIP0016-ban definiált ((("pay-to-script-hash (P2SH)","coinbase adatok és")))Fizetés-a-script-hashnek (P2SH) bővítést. A P2SH opció bevezetése megkövetelte, hogy a bányászok „szavazzanak”, hogy a BIP0016-ot vagy a BIP0017-et támogatják. Azok, akik a BIP0016-ot támogatták, a +/P2SH/+-t tették a coinbase adatmezőbe. Azok, akik a P2SH BIP0017 szerinti megvalósítását támogatták, a +p2sh/CHV+-t tették a coinbase adatmezőbe. A BIP0016 lett győztes, de sok bányász továbbra is beteszi a +/P2SH/+ stringet a coinbase mezőbe, így jelezve, hogy támogatja ezt az opciót.

A <<satoshi_words>> az <<alt_libraries>>  részben bevezetett libbitcoin könyvtárra támaszkodva veszi ki a genezis blokkból a coinbase adatokat és jeleníti meg Satoshi üzenetét. Megjegyezzük, hogy a libbitcoin könyvtár tartalmazza a genezis blokk egy statikus másolatát, ezért a példa program közvetlenül a könyvtárból tudja elővenni a genezis blokkot. 

[[satoshi_words]]
.A genezis blokkban lévő coinbase adatok megjelenítése
====
[source, cpp]
----
include::code/satoshi-words.cpp[]
----
====

A kódot a GNU C++ fordítóprogrammal fordítottuk le. Futtatása a <<satoshi_words_run>> szerint történt.(((range="endofrange", startref="ix_ch08-asciidoc12")))(((range="endofrange", startref="ix_ch08-asciidoc11")))(((range="endofrange", startref="ix_ch08-asciidoc10")))

[[satoshi_words_run]]
.A "Satoshi szavai" példaprogram fordítása és futtatása
====
[source,bash]
----
$ # A kód lefordítása
$  g++ -o satoshi-words satoshi-words.cpp $(pkg-config --cflags --libs libbitcoin)
$ # A végrehajtható program futtatása
$ ./satoshi-words
^D��<GS>^A^DEThe Times 03/Jan/2009 Chancellor on brink of second bailout for banks (magyarul: A pénzügyminiszter hajlik a bankok második kimentésére.)
----
====

=== A blokkfej előállítása

((("blokk fejek","előállítása")))A blokkfej előállításához a bányász csomópontnak a <<block_header_structure_ch08>>-ben látható következő hat mezőt kell kitöltenie:

[[block_header_structure_ch08]]
.A blokkfej szerkezete 
[options="header"]
|=======
|Méret | Mező | Leírás
| 4 bájt | Version | A szoftver/protokoll változásokat nyomon követő verziószám
| 32 bájt | Previous Block Hash | Hivatkozás a blokklánc előző (szülő) blokkjának a hash-ére
| 32 bájt | Merkle Root | A blokk tranzakcióihoz tartozó Merkle-fa gyökerének a hash-e
| 4 bájt | Timestamp | Időbélyeg: hozzávetőleg mikor jött létre a blokk (a Unix kezdőidő óta eltelt másodpercek)
| 4 bájt | Difficulty Target | A munkabizonyíték algoritmus által megkövetelt cél nehézségi szint
| 4 bájt | Nonce | A munkabizonyíték algoritmus által használt számláló
|=======

A 277'316-ik blokk kibányászásakor a blokk szerkezetére jellemző verziószám „2” volt, amelyet a legkisebb helyiértékű bájt első helyre írásával, 4 bájton a +0x02000000+ ábrázol. 

Ezután a bányász csomópontnak az ((("Előző blokk hash-e")))„Előző blokk hash-ét” kell betennie a fejbe. Ez a hálózattól előzőleg kapott 277'315-ik blokk blokkfejének a hash-e, melyet Jing csomópontja az ellenőrzés után a 277'316-ikként létrehozandó blokk szülőjének válaszott. A 277'315-ik blokk blokkfejének a hash-e:

----
0000000000000002a7bbd25a417c0374cc55261021e8a9ca74442b01284f0569
----

((("merkle fák","blokk fej előállítása ~kal")))A következő lépés a tranzakció összesítése egy Merkle-fa formájában, mely ahhoz szükséges, hogy a Merke-fa gyökere bekerülhessen a blokkfejbe. A generáló tranzakció a blokk első tranzakciója. Ezt még 418 további tranzakció követi, vagyis összesen 419 tranzakció van a blokkban. Amint azt a <<merkle_trees>> részben láttuk, a fában páros számú „levél” csomópontnak kell lennie, ezért az utolsó tranzakciót meg kellett duplázni, hogy a blokkban 420 csomópont legyen. Mindegyik csomópont egy tranzakció hash-ét tartalmazza. A tranzakció hash-eket a bányász csomópont eztután párokba rendezi, és létrehozza a fa minden egyes szintjét, míg végül az összes tranzakcióból eljut a fa „gyökerét” alkotó csomóponthoz. A Merkle fa gyökere az összes tranzakciót egyetlen egy 32 bájtos értékbe sűríti, amely a  <<block277316>> "Merkle-gyökere", esetünkben: 

----
c91c008c26e50763e9f548bb8b2fc323735f73577effbc55502c51eb4cc7cf2e
----
    
((("blokkok időbélyege")))A bányász csomópont ezután egy 4 bájtos időbélyeget tesz a blokkfejbe. Az időbélyeg Unix „Epoch” időbélyegként van kódolva, ami az 1970. január 1. éjfél (UTC/GMT) óta eltelt másodpercek száma. A +1388185914+ érték 2013. december 27. 23:11:54 UTC/GMT időnek felel meg.

((("cél nehézségi szint","blokk fej előállítás és")))A csomópont ezután kitölti a megkívánt nehézségi szintet – ettől függ, hogy milyen bonyolult munkabizonyítékra van szükség ahhoz, hogy érvényes legyen a blokk. A bonyolultságot a blokk a „nehézség mértéke” bitekben tárolja, amely a cél nehézségi szintet kódolja mantissza és kitevő formájában. A kitevő 1 bájtos, ezt egy 3 bájtos mantissza követi. A 277'316-ik blokk esetében a nehézségi szinthez tartozó bitek értéke +0x1903a30c+. Az első rész, +0x19+, egy hexadecimális kitevő, míg a következő rész, a +0x03a30c+ a mantissza. A cél nehézségi szint magyarázata a <<difficulty_target>> részben, míg a „nehézségi szintet megadó bitek” magyarázata a <<difficulty_bits>> részben szerepel.

((("nonce,","inicializálása a blokk fejben")))Az utolsó mező a nonce, amelybe 0 kezdőérték kerül. 

A mezők kitöltésével a blokk fej teljessé vált, és kezdődhet a bányászat folyamata. A cél az, hogy egy olyan nonce értéket találjunk, amelynél a blokk fej hash-e kisebb, mint a cél nehézségi szint. A bányász csomópont nonce értékek billióit és trillióit ellenőrzi, hogy egy olyan nonce értéket találjon, amely megfelel ennek a feltételnek.

=== A blokk kibányászása

((("blokkok","bányászat", id="ix_ch08-asciidoc13", range="startofrange")))((("bányászat","blokkok", id="ix_ch08-asciidoc14", range="startofrange")))Most, hogy Jing csomópontja megkonstruálta az előállítandó blokk jelöltet, Jing hardver "platformján" a sor, hogy "kibányássza" a blokkot, vagyis olyan megoldást találjon a munkabizonyíték algoritmusra, amely a blokkot érvényesé teszi. Könyvünkben sokat tanulmányoztuk, hogy a bitcoin rendszer hogyan használja a kriptográfiai hash függvényeket.. A bitcoin bányszat folyamata az SHA256 függvényt használja. 

 A bányászat egyszerűen az a folyamat, melynek során a blokkfej hash-e egy paraméter megváltoztatása után ismételten kiszámításra kerül, mindaddig, amíg a hash meg nem felel egy adott cél értéknek. A hash függvény eredményét előre nem ismert, és olyan bemenet sem adható meg, amely egy adott hash értéket hoz létre. A hash függvény ezen jellemzői miatt egy adott célt kielégítő hash érték csak úgy állítható elő, ha újra és újra próbálkozunk, és a bement értékét mindaddig változtatjuk, amíg a kívánt hash eredmény véletlenül elő nem áll. 

==== Munkabizonyíték algoritmus

((("bányászat","munkabizonyíték algoritmus és", id="ix_ch08-asciidoc15", range="startofrange")))((("munkabizonyíték algoritmus", id="ix_ch08-asciidoc16", range="startofrange")))Egy hash algoritmus egy tetszőleges hosszúságú bemenő adatból egy fix hosszúságú, determinisztikus kimenetet állít elő: a bemenet digitális ujjlenyomatát. Egy adott bemenet esetén az eredményként kapott hash mindig ugyanaz lesz. Az eredményt bárki könnyen kiszámíthatja és ellenőrizheti, ha lefuttatja ugyanazt a hash algoritmust. A kriptográfiai hash algoritmusok alapvető jellemzője, hogy lényegében lehetetlen két olyan bemenetet találni, amely ugyanazt az ujjlenyomatot állítja elő. Ennek következtében az is lehetetlen, hogy egy adott ujjlenyomathoz találjunk egy bemenetet, amely épp ezt az ujjlenyomatot állítja elő. Csak próbálgatni tudunk: egy véletlenszerű bemenetnek kiszámítjuk az ujjlenyomatát, és ellenőrizzük, hogy ez az ujjlenyomat egyezik-e a megadott ujjlenyomattal.

Az SHA256 esetén a bemenet méretétől függetlenül a kimenet mindig 256 bit hosszú.A lenti <<sha256_example1>> példában egy Python interpreterrel számítjuk ki az „I am Satoshi Nakamoto” kifejezés SHA256 hash értékét. 

[[sha256_example1]]
.SHA256 példa
====
[source,bash]
----
$ python
----
[source,pycon]
----
Python 2.7.1
>>> import hashlib
>>> print hashlib.sha256("I am Satoshi Nakamoto").hexdigest()
5d7c7ba21cbbcd75d14800b100252d5b428e5b1213d27c385bc141ca6b47989e
----
====

Az <<sha256_example1>> példa szerint az +"I am Satoshi Nakamoto"+ kifejezés hash-e +5d7c7ba21cbbcd75d14800b100252d5b428e5b1213d27c385bc141ca6b47989e+. Ez a 256 bites szám a kifejezés _hash_-e vagy _zanzája_, és a kifejezés minden egyes karakterétől függ az értéke. Már egyetlen betű megváltoztatása teljesen különböző hash értéket eredményez.

Ha megváltoztatjuk ezt a kifejezést, akkor azt várjuk, hogy teljesen különböző hash értékeket kapunk. Próbáljuk ezt ki. Egy egyszerű <<sha256_example_generator>> Python scripttel tegyünk a kifejezés végére egy számot:

[[sha256_example_generator]]
.Nonce növeléssel SHA256 hasheket előállító script
====
[source, python]
----
include::code/hash_example.py[]
----
====

Ennek futtatásával azoknak a kifejezéseknek a hash-ei állíthatók elő, melyek a fenti szöveg és egy szám összefűzésével álltak elő. A szám növelésekor különböző hasheket kapunk, ezt a <<sha256_example_generator_output>> mutatja.

((("nonce")))
[[sha256_example_generator_output]]
.A nonce növeléssel SHA256 hasheket előállító script kimenete
====
[source,bash]
----
$ python hash_example.py
----

----
I am Satoshi Nakamoto0 => a80a81401765c8eddee25df36728d732...
I am Satoshi Nakamoto1 => f7bc9a6304a4647bb41241a677b5345f...
I am Satoshi Nakamoto2 => ea758a8134b115298a1583ffb80ae629...
I am Satoshi Nakamoto3 => bfa9779618ff072c903d773de30c99bd...
I am Satoshi Nakamoto4 => bce8564de9a83c18c31944a66bde992f...
I am Satoshi Nakamoto5 => eb362c3cf3479be0a97a20163589038e...
I am Satoshi Nakamoto6 => 4a2fd48e3be420d0d28e202360cfbaba...
I am Satoshi Nakamoto7 => 790b5a1349a5f2b909bf74d0d166b17a...
I am Satoshi Nakamoto8 => 702c45e5b15aa54b625d68dd947f1597...
I am Satoshi Nakamoto9 => 7007cf7dd40f5e933cd89fff5b791ff0...
I am Satoshi Nakamoto10 => c2f38c81992f4614206a21537bd634a...
I am Satoshi Nakamoto11 => 7045da6ed8a914690f087690e1e8d66...
I am Satoshi Nakamoto12 => 60f01db30c1a0d4cbce2b4b22e88b9b...
I am Satoshi Nakamoto13 => 0ebc56d59a34f5082aaef3d66b37a66...
I am Satoshi Nakamoto14 => 27ead1ca85da66981fd9da01a8c6816...
I am Satoshi Nakamoto15 => 394809fb809c5f83ce97ab554a2812c...
I am Satoshi Nakamoto16 => 8fa4992219df33f50834465d3047429...
I am Satoshi Nakamoto17 => dca9b8b4f8d8e1521fa4eaa46f4f0cd...
I am Satoshi Nakamoto18 => 9989a401b2a3a318b01e9ca9a22b0f3...
I am Satoshi Nakamoto19 => cda56022ecb5b67b2bc93a2d764e75f...
----
====

Minden egyes kifejezésnek teljesen más a hash értéke. A hash értékek teljesen véletlenszerűnek látszanak, ugyanakkor az eredmények egy másik számítógépen futó Python-nal pontosan reprodukálhatók, és pontosan ugyanezeket a hash értékeket eredményezik. 

Az ilyen helyzetben használt változó számláló neve: _nonce_. A nonce segítségével befolyásolhatjuk a kriptográfiai függvény kimenetét, ebben az esetben a kifejezés SHA256 ujjlenyomatát. 

((("cél nehézségi szint","definíciója")))Egy cél nehézségi szint megadásával állítsuk kihívás elé ezt az algoritmust: próbáljuk egy olyan kifejezést találni, amelynek hash-e 0-val kezdődik. Szerencsére, ez nem olyan nehéz! A <<sha256_example_generator_output>> szerint az „I am Satoshi Nakamoto13” által előállított hash értéke +0ebc56d59a34f5082aaef3d66b37a661696c2b618e62432727216ba9531041a5+, amely megfelel ennek a követelménynek. 13 kísérlet kellett hozzá, hogy megtaláljuk ezt a stringet. A valószínűségszámítás nyelvén, ha a hash függvény kimenete egyenletes eloszlású, akkor várhatóan minden 16 darab hash között lesz egy olyan, amely a 0 hexadecimális számjeggyel kezdődik (mivel a 16 hexadecimális számjegy, 0 .. F között ez az egyik számjegy). Számszerűsítve mindezt, egy olyan hash értéket keresünk, amely kisebb mint +0x1000000000000000000000000000000000000000000000000000000000000000+. Ezt a küszöbértéket _célnak_ nevezzük, mivel egy olyan hash értéket szeretnénk találni, amely _kisebb mint a cél_. Ha csökkentjük a cél értékét, egyre nehezebb és nehezebb lesz ennél a célnál kisebb hash értéket találnunk. 
 
Egy egyszerű hasonlattal élve, képzeljünk el egy olyan játékot, amelyben a játékosok két kocka ismételt feldobását végzik, és próbálnak egy olyat dobni, ahol az összeg egy adott célnál kevesebb. Első körben legyen a cél 12. Ekkor mindegyik dobás megfelelő, kivéve, ha mindkét kockával 6-ost dobnak. A következő körben legyen a nehézség 11. Ekkor 10-et vagy kevesebbet kell dobniuk a játékosoknak, ami ismét csak könnyű feladat. Néhány körrel később legyen a cél 6. Ekkor a kockadobások több mint felénél az összeg több lesz mint 5, vagyis a dobás sikertelen lesz. Minél kisebb a cél, annál több kockadobásra van szükség a győzelemhez, és a kockadobások száma exponenciálisan nő. Végül, ha a cél 3 (a lehetséges minimum), akkor minden 36 dobásból 1 (2%) fog győzelemhez vezetni. 

A  <<sha256_example_generator_output>> példában a „nyerő” nonce 13, amit bárki ellenőrizhet, ha hozzáteszi az „I am Satoshi Nakamoto” string végéhez a 13-as számot, és kiszámíthatja az „I am Satoshi Nakamoto13” kifejezés hash értéket. Látni fogja, hogy a hash értéke kisebb, mint a cél. A sikeres eredmény egyúttal egy munkabizonyítékot (Proof-of-Work) jelent, mivel bizonyítja, hogy elvégeztük a fenti nonce megkereséséhez szükséges munkát. Az ellenőrzéhez csak 1 darab hash kiszámítására van szükség, ugyanakkor a {feltételnek megfelelő} nonce érték előállításához 13 darab hash kiszámításra volt szükség. Ha alacsonyabb a cél (magasabb a bonyolultság), akkor a cél feltételt kielégítő nonce előállításához sokkal több hash kiszámításra lett volna szükség, de az ellenőrzéséhez továbbra is csak egy hash kiszámítása szükséges. Ha tudjuk a célt, akkor ki tudjuk számítani a bonyolultságot, és ennek megfelelően tudjuk, hogy mennyi munka szükséges ahhoz, hogy egy ilyen nonce értéket találjunk.

A Bitcoin munkabizonyítéka nagyon hasonló a fenti <<sha256_example_generator_output>> problémában szereplő munkabizonyítékoz. A bányász előállít egy jelölt blokkot, amelyet tranzakciókkal tölt föl. Ezt követően a bányász kiszámítja a blokkfej hash-ét, és megvizsgálja, hogy az kisebb-e, mint az aktuális cél. Ha a hash értéke nem kisebb a célnál, akkor a bányász módosítja a nonce-t (általában úgy, hogy megnöveli eggyel), és újra próbálkozik. A bitcoin hálózat jelenlegi bonyolultsági szintje mellett a bányászoknak sok billiószor kell próbálkozniuk ahhoz, hogy egy olyan nonce értéket találjanak, amely elég kicsiny blokkfej hash értéket eredményez.

Az alábbi <<pow_example1>> Python kód egy nagyon leegyszerűsített ((("munkabizonyíték")))munkabizonyíték algoritmust (Proof-of-Work algorithm) valósít meg:

[[pow_example1]]
.Egy egyszerű munkabizonyíték algoritmus
====
[source, python]
----
include::code/proof-of-work-example.py[]
----
====

A fenti kód futtatásakor beállítható a kívánt nehézség (bitekben, vagyis hogy hány bit legyen a hash elején nulla), és megvizsgálható, hogy mennyi idő szükésges tart egy megoldáshoz. A <<pow_example_outputs>> mutatja, hogy egy átlagos laptop-on hogyan működik az algoritmus:

[[pow_example_outputs]]
.A munkabizonyíték példa futtatása különféle nehézségi szintekre
====
[source, bash]
----
$ python proof-of-work-example.py*
----

----
Difficulty: 1 (0 bits)

[...]

Difficulty: 8 (3 bits)
Starting search...
Success with nonce 9
Hash is 1c1c105e65b47142f028a8f93ddf3dabb9260491bc64474738133ce5256cb3c1
Elapsed Time: 0.0004 seconds
Hashing Power: 25065 hashes per second
Difficulty: 16 (4 bits)
Starting search...
Success with nonce 25
Hash is 0f7becfd3bcd1a82e06663c97176add89e7cae0268de46f94e7e11bc3863e148
Elapsed Time: 0.0005 seconds
Hashing Power: 52507 hashes per second
Difficulty: 32 (5 bits)
Starting search...
Success with nonce 36
Hash is 029ae6e5004302a120630adcbb808452346ab1cf0b94c5189ba8bac1d47e7903
Elapsed Time: 0.0006 seconds
Hashing Power: 58164 hashes per second

[...]

Difficulty: 4194304 (22 bits)
Starting search...
Success with nonce 1759164
Hash is 0000008bb8f0e731f0496b8e530da984e85fb3cd2bd81882fe8ba3610b6cefc3
Elapsed Time: 13.3201 seconds
Hashing Power: 132068 hashes per second
Difficulty: 8388608 (23 bits)
Starting search...
Success with nonce 14214729
Hash is 000001408cf12dbd20fcba6372a223e098d58786c6ff93488a9f74f5df4df0a3
Elapsed Time: 110.1507 seconds
Hashing Power: 129048 hashes per second
Difficulty: 16777216 (24 bits)
Starting search...
Success with nonce 24586379
Hash is 0000002c3d6b370fccd699708d1b7cb4a94388595171366b944d68b2acce8b95
Elapsed Time: 195.2991 seconds
Hashing Power: 125890 hashes per second

[...]

Difficulty: 67108864 (26 bits)
Starting search...
Success with nonce 84561291
Hash is 0000001f0ea21e676b6dde5ad429b9d131a9f2b000802ab2f169cbca22b1e21a
Elapsed Time: 665.0949 seconds
Hashing Power: 127141 hashes per second
----
====

Mint látható, a nehézségi szint 1 bittel történő megnövelése exponenciálisan növeli a megoldás megkereséséhez szükséges időt. Ha az egész 256-bites számteret tekintjük, akkor minden egyes alkalommal, amikor egy további bittől megköveteljük a nullák számát, megfelezzük a keresési tért. A fenti <<pow_example_outputs>> példában 84 millió próbálkozás kellett ahhoz, hogy egy olyan nonce értéket találjunk, amelynél a hash első 26 bitje nulla. Még 120 ezer hash /másodperc sebességnél is több mint 10 percbe került, hogy egy közönséges laptop-on megtaláljuk ezt a megoldást. 

Amikor e sorokat írom, a hálózat olyan blokkot próbál találni, amelynél a blokkfej hash értéke kevesebb, mint +000000000000004c296e6376db3a241271f43fd3f5de7ba18986e517a243baa7+. Mint látják, sok-sok nulla van a hash elején, ami azt jelenti, hogy a megengedhető hash tartomány sokkal kisebb, emiatt sokkal nehezebb egy ennek megfelelő hash értéket találni. Átlagosan több mint 150 ezer billió hash számításra van szükség másodpercenként, hogy a halózat a megtalálja a következő blokkot. Ez szinte megoldhatatlan feladatnak látszik, de szerencsére a hálózat 100 Petahash/sec számítási teljesítménnyel rendelkezik, ami lehetővé teszi, hogy átlagosan 10 perc alatt találjon egy blokkot.(((range="endofrange", startref="ix_ch08-asciidoc16")))(((range="endofrange", startref="ix_ch08-asciidoc15"))) 

[[difficulty_bits]]
==== A nehézségi szint ábrázolása

((("nehézségi szint")))((("bányászat","nehézségi szintet meghatározó bitek")))((("bányászat","nehézségi szint")))A <<block277316>> blokknál láttuk, hogy a blokkfej tartalmazza a nehézségi célt, olyan jelölésmódban, amit „nehézségi szintet meghatározó biteknek” vagy egyszerűen csak „biteknek” hívunk. A 277'316-ik blokk esetén ez az érték +0x1903a30c+. Ez a jelölésmód mantissza/kitevő formátumban fejezi ki a kívánt nehézségi szintet, ahol az első két hexa számjegy a kitevő, a következő hat hexa számjegy pedig a mantissza. Ennek megfelelően ebben a blokkban a kitevő +0x19+, a mantissza pedig +0x03a30c+.
    
A kívánt nehézségi szint ebből az ábrázolásból a következő képlettel számítható ki:

----
cél = mantissza * 2 ^ (8*(kitevő - 3))
----

Ha a képletet a 0x1903a30c nehézségi bitekre vonatkozóan a használjuk, akkor azt kapjuk, hogy:

----
cél = 0x03a30c * 2^(0x08 * (0x19 - 0x03))^ 

⇒ cél = 0x03a30c * 2^(0x08 * 0x16)^

⇒ cél = 0x03a30c * 2^0xB0^
----

ami decimálisan:

----
⇒ cél = 238,348 * 2^176^

⇒ cél = 22'829'202'948'393'929'850'749'706'076'701'368'331'072'452'018'388'575'715'328
----

Ezt hexadecimális alakra visszaírva:

----
⇒ cél = 0x0000000000000003A30C00000000000000000000000000000000000000000000
----

Ez azt jelenti, hogy a 277'316 magasságban az a blokk érvényes, melynél a blokk fej hash-ének értéke kisebb, mint a cél. Binárisan ez a szám több, mint 60 db nullával kezdődik. Ennél a nehézségi szintnél egy olyan bányász, amely másodpercenként 1 billió hash értéket képes kiszámítani (ami másképpen 1 terahash másodpercenként, azaz 1 TH/sec), átlagosan csak minden 8496 blokkonként (vagyis 59 naponta ) fog egy megoldást találni. 

[[difficulty_target]]
==== A cél nehézségi szint és a nehézségi szint újraszámítása

((("nehézségi szint","újraszámítása", id="ix_ch08-asciidoc17", range="startofrange")))Mint azt fent láttuk, a cél határozza meg a nehézégi szintet, és emiatt közvetlenül befolyásolja, hogy mennyi idő szükséges a munkabizonyíték (Proof-of-Work) algoritmus megoldásához. Ez viszont felveti a következő nyilvánvaló kérdést: ha a nehézségi szint állítható, akkor ki állítja és hogyan?

((("nehézségi szint újraszámítása")))((("cél nehézségi szint","blokk generálás üteme és")))A bitcoin blokkjai átlagosan 10 percenként állnak elő. Ez a bitcoin szívverése, ami a pénzkibocsátás gyakoriságát és a tranzakciók elszámolását határozza meg. Nem csak rövid távon, hanem hosszú évtizedek során is állandónak kell maradnia. Azt várjuk, hogy idővel gyors ütemben nő majd a számítási kapacitás. Ezen kívül a bányászatban részt vevők száma és az általuk használt berendezések száma szintén állandóan változik. Ha azt szeretnénk, hogy a blokk előállítás ideje 10 perc maradjon, a bányászat nehézségét úgy kell szabályozni, hogy figyelembe vegye ezeket a körülményeket. És valóban, a nehézségi szint egy dinamikus paraméter, amelynek időről időre történő állításával elérhető, hogy teljesüljön a 10 perces blokk előállítási idő. Leegyszerűsítve, a cél nehézségi szint mindig úgy fog beállni, hogy  a bányászok teljesítményétől függetlenül 10 perc legyen a blokkok közötti idő. 

Hogyan lehet egy teljesen decentralizált hálózatban egy ilyen beállítást elvégezni? A cél nehézségi szint újraszámítása minden teljes csomóponton automatikusan és a többi csomóponttól teljesen függetlenül történik. Minden 2016 darab blokk után mindegyik csomópont újraszámítja a nehézségi szintet. A nehézségi szint újraszámítsára szolgáló képletben a 2016 darab blokk tényleges előállításához szükséges időt hasonlítják össze a várt 20'160 perces értékkel (ami a kívánatos 10 perces blokk idő esetén két hét). A ténylegesen eltelt idő és a kívánt idő hányadosának kiszámítása után megtörténik a nehézségi szint szükséges korrekciója (fölfelé vagy lefelé). Leegyszerűsítve: Ha a hálózat átlagosan 10 percnél hamarabb találja meg a blokkokat, akkor a nehézségi szint nő. Ha a blokkok előállítása lassabb a vártnál, akkor a nehézségi szint csökken. 

Az egyenlet a következőképpen foglalható össze:

----
Új_nehézség = Régi_nehézség * (Az_utolsó_2016_blokk_előállításának_ideje / 20160 perc)
----

A <<retarget_difficulty_code>> a Bitcoin Core kliensen belül használt kódot mutatja

[[retarget_difficulty_code]]
.A munkabizonyíték nehézségi szintjének újraszámítása – +GetNextWorkRequired()+, pow.cpp, 43-ik sor
====
[source,cpp]
----

// Visszalépünk annyival, hogy 14 napnak megfelelő blokkunk legyen
const CBlockIndex* pindexFirst = pindexLast;
for (int i = 0; pindexFirst && i < Params().Interval()-1; i++)
    pindexFirst = pindexFirst->pprev;
assert(pindexFirst);

// Korlátozzuk a módosítás mértékét
int64_t nActualTimespan = pindexLast->GetBlockTime() - pindexFirst->GetBlockTime();
LogPrintf("  nActualTimespan = %d  before bounds\n", nActualTimespan);
if (nActualTimespan < Params().TargetTimespan()/4)
    nActualTimespan = Params().TargetTimespan()/4;
if (nActualTimespan > Params().TargetTimespan()*4)
    nActualTimespan = Params().TargetTimespan()*4;

// Újraszámítjuk a nehézségi szintet
uint256 bnNew;
uint256 bnOld;
bnNew.SetCompact(pindexLast->nBits);
bnOld = bnNew;
bnNew *= nActualTimespan;
bnNew /= Params().TargetTimespan();

if (bnNew > Params().ProofOfWorkLimit())
    bnNew = Params().ProofOfWorkLimit();

----
====

[NOTE]
====
Míg a nehézségi szint újraszámítása 2016 blokkonként történik, az eredeti Bitcoin Core kliens egy hiba miatt az előző 2015 blokk idejét veszi figyelembe (nem 2016 darabét, ahogyan azt kellene). Emiatt a nehézségi szint 0.05%-kal magasabb lesz, mint kellene.
====


Az Interval paramétert (2016 blokk) és a TargetTimespan paramétert (két hét, azaz 1'209'600 másodperc) a _chainparams.cpp_ definiálja.

A nehézségi szint nagy ingadozásainak elkerülése érdekében a módosító tényezőnek ciklusonként (2016 blokkonként) 4-nél kisebbnek kell lennie. Ha a kívánt nehézségi szint módosítás több mint négyszeres, akkor a maximum 4-re lesz állítva. A továbi állítások a következő körben fognak megvalósulni, és a következő 2016 blokkban fennmarad az egyensúlyhiány. Emiatt a hash kapacitás és a nehézségi szint közötti nagy eltérések kiegyenlítődéséhez egynél több 2016 blokkos ciklusra lehet szükség. 

[TIP]
====
A teljes bitcoin hálózatban kb. 10 perc szükséges az egész hálózat számára egy blokk előállításához, ami az előző 2016 blokk előállításához szükséges idő alapján, 2016 blokkonként újraszabályozásra kerül.
====

Figyeljék meg, hogy a cél nehézségi szint független a tranzakciók számától vagy értékétől. Ez azt jelenti, hogy a bitcoin hálózat biztonságának megteremtésre fordított hash kapacitás, vagyis villamos energia szintén teljesen független a tranzakciók számától. Ha a bitcoin elterjedtebbé válik, akkor sem lesz szükséges, hogy a bizonság érdekében a hash kapacitás a mai szinthez képest tovább növekedjen. A hash kapacitás növekedése olyan piaci erőknek tudható be, mint a jutalomért versengő újabb bányászok megjelenése. Amíg a jutalomért versenyző bányászok között elég sok becsületes bányász van, addig nem lehetséges a hálózat „kisajátítása”, és emiatt elégségesek ahhoz, hogy a bitcoin biztonságos maradjon. 

((("cél nehézségi szint","villamos energia költségek és")))((("villamos energia költségek és cél nehézségi szint")))A cél nehézségi szint szoros kapcsolatban a villamos energia árával és a bitcoin átváltási árfolyamával, t.i. a bányászok a villanyszámlát hagyományos papírpénzzel fizetik. A nagy kapacitású bányász "farmok" a lehető leggazdaságosabban működnek, a legmodernebb integrált áramköröket (ASIC) használják, és a villamos energiát a lehető leghatékonyabban alakítják át hash számításokká. A bányászokra a legközvetlenebb hatást 1 kWh bitcoinban mért ára jelenti, mivel ez határozza meg a bányászat jövedelmezőségét, vagyis azt, hogy érdemes-e belépni erre a piacra, vagy be kell szüntetni a tevékenységet.(((range="endofrange", startref="ix_ch08-asciidoc17")))(((range="endofrange", startref="ix_ch08-asciidoc14")))(((range="endofrange", startref="ix_ch08-asciidoc13")))

=== A blokk sikeres kibányászása

((("konszenzus","blokkok sikeres bányászata")))Mint azt korábban láttuk, Jing csomópontja előállított egy blokk jelöltet és előkészítette a bányászathoz. Jingnek számos ((("Application Specific Integrated Circuit (ASIC)","bányászat ezekkel")))((("Berendezés Orientált integrált ÁramKör (BOÁK)","bányászat ezekkel")))ASIC (ASIC = Application Specific Integrated Circuit, BOÁK, Berendezés Orientált Árakör) alapú bányász berendezése van, amelyekben az integrált áramkörök SHA256 algoritmusok ezreit futtatják egyással párhuzamosan, hihetetlen sebességgel. Ezek a specializált gépek USB-vel kapcsolodnak hozzá a bányász csomóponthoz. A Jing asztali számítógépén futó bányász csomópont elküldi a blokkfejet a bányász hardvernek, amitöbb billió nonce / másodperc sebességgel  elkezdi tesztelni a nonce-okat. 

A 277'316-ik blokk bányászatának megkezdése után majdnem 11 perccel az egyik hardver talál egy megoldást, és visszaküldi a bányász csomópontnak. A nonce 4'215'469'401 , melyet a következő blokk hash-t eredményezi:

----
0000000000000002a7bbd25a417c0374cc55261021e8a9ca74442b01284f0569
----

amely kisebb, mint a megkívánt cél:

----
0000000000000003A30C00000000000000000000000000000000000000000000
----

Jing számítógépe azonnal elküldi a blokkot a szomszédos csomópontoknak. Ezek fogadják, ellenőrzik, majd továbbítják az új blokkot. Amint a blokk szétterjed a hálózaton, mindegyik csomópont hozzáadja ezt a blokkot a saját blokkláncához, így a blokklánc magassága 277'316-ra nő. Miután a bányász csomópontok megkapták és ellenőrizték az új blokkot, abbahagyják annak blokk keresését, melynek a 277'315-ik blokk a szülője, és azonnal hozzálátnak a lánc következő blokkjának a kiszámításához. 

A következő részben azt a folyamatot fogjuk megvizsgálni, amellyel az egyes csomópontok ellenőrzik a blokkot és kiválasztják a leghosszabb láncot, megteremtve ezáltal azt a közmegegyezést, amely a decentralizált blokklánc létrejöttének az alapja.

=== Az új blokk ellenőrzése

((("blokkok","új ~ ellenőrzése")))((("konszenzus","új blokkok ellenőrzése")))((("bányászat","új blokkok ellenőrzése"))))A bitcoin konszenzus mechanizmusának harmadik eleme a blokkok egymástól független ellenőrzése, amely a hálózat minden egyes csomópontján végbemegy. Az újonnan keletkezett blokkok hálózati szétterjedésekor mindegyik csomópont egy tesztsorozatot végez, mielőtt a blokkot továbbítaná a peer-jeinek. Ez biztosítja, hogy a hálózatban csak érvényes blokkok terjedhessenek szét. A blokkok független ellenőrzése azt is biztosítja, hogy a becsületes bányászok blokkjai beépülnek a blokkláncba, és a bányász ezáltal hozzájut a jutalmához. A csaló bányászok blokkjait viszont a többiek elvetik, és így a bányász nem csupán a jutalomtól esik el, hanem a munkabizonyíték előállításához elvégzett munkája is pocsékba megy, vagyis a villamos energia költségét nem kompenzálja semmi. 

Ha egy csomópontba új blokk érkezik, akkor a csomópont a blokkot egy hosszú feltétellista alapján ellenőrzi. A blokknak az össze feltételt teljesítenie kell, különben a blokkot elveti a csomópont. Ezek a feltételek a Bitcoin Core kliens ((("CheckBlock függvény (Bitcoin Core kliens)")))((("CheckBlockHeader függvény (Bitcoin Core kliens)"))) +CheckBlock+ és +CheckBlockHeader+ függvényeiben találhatók meg. A feltételek a következők:

* a blokk adatstruktúrája szintaktikusan érvényes
* a blokkfej hash-e kisebb, mint a cél nehézségi szint (a munkabizonyíték betartatása)
* a blokk időbélyege kevesebb, mint két órával mutat a jövőbe (óra hibák engedélyezése)
* a blokk mérete a megengedett határok között van
* az első (és csak az első) tranzakció egy coinbase tranzakció
* a <<tx_verification>> tranzakciós ellenőrző lista alapján a blokkban lévő összes tranzakció érvényes

A hálózat mindegyik csomópontja által, a többi csomóponttól függetlenül elvégzett ellenőrzések biztosítják, hogy a bányászok ne csalhassanak. Az előző részben láttuk, hogy egy bányász hogyan tud olyan tranzakciót létehozni, amely a blokkban létrejött bitcoinokat és a tranzakciós díjakat a bányász saját címére utalja. Miért nem írnak a bányászok ebbe a tranzakcióba több ezer bitcoint a jutalom helyes összege helyett? Mert mindegyik csomópont ugyanazon szabályok szerint ellenőrzi a blokkokat. Egy érvénytelen coinbase tranzakció az egész blokkot érvénytelenné tenné, ami miatt a többi csomópont elvetné a blokkot és a blokk soha nem válna a főkönyv részévé. Egy bányásznak tökéletesen helyes blokkot kell előállítania, amely megfelel a többi csomópont által követett közös szabályoknak, és a munkabizonyíték helyes megoldását tartalmazza. A bányászathoz sok villamos energia szükséges, ami a csalás esetén nem térül meg. A blokkok független ellenőrzése emiatt kulcsfontosságú a decentralzált konszenzus megteremtése szempontjából.

=== A blokklánc összeállítása és kiválasztása

((("blokkláncok","összeállítása", id="ix_ch08-asciidoc18", range="startofrange")))((("blokkláncok","kiválasztása", id="ix_ch08-asciidoc19", range="startofrange")))((("blokkok","összeállítása blokkláncokká", id="ix_ch08-asciidoc20", range="startofrange")))((("blokkok","láncainak kiválasztása", id="ix_ch08-asciidoc21", range="startofrange")))A bitcoin rendszer decentralizált konszenzus mechanizmusának utolsó lépése a blokkok láncokba történő szervezése, és annak a blokkláncnak a kiválasztása, amely a legtöbb munkabizonyítékot tartalmazza. Ha egy csomópont elvégezte a blokkk ellenőrzését, akkor megkísérli a blokklánc bővítését, vagyis a blokk és a már létező blokklánc összekapcsolását. 

((("csomópontok","által nyilvántartott blokkok fajtái")))A csomópontok háromféle blokkot tartanak nyilván: a fő blokklánchoz kapcsolódó blokkokat, a fő blokklánc elágazásain lévő blokkokat ((("másodlagos láncok"))) (másodlagos láncok) és végül azokat a blokkokat, amelyeknek az ismert blokkláncban nincsenek szülei ((("árva blokkok"))) (árva blokkok). Ha valamelyik ellenőrzési feltétel nem teljesül, akkor az érvénytelen blokkot a csomópont azonnal elveti, emiatt a blokk egyik blokkláncba sem kerül be. 

((("blokklánc","fő")))((("fő blokklánc")))A „fő lánc” egy adott időpillanatban az a blokklánc, amelyben a nehézségi szint kummulált értéke a legnagyobb. A legtöbb esetben ez azonos a legtöbb blokkot tartalmazó lánccal, kivéve, ha két lánc azonos hosszúságú, mert ekkor a több munkabizonyítékot tartalmazó lánc lesz a fő lánc. A fő láncról elágazó láncok blokkjai a fő láncon lévő blokkok  ((("tetvér láncok (a fő lánc mellett)")))„testvérei”. Ezek a blokkok érvényesek ugyan, de nem részei a fő láncnak. Azért tartják meg őket, mert előfordulhat, hogy valamelyik elágazó lánc bővülése miatt az elágazó lánc nehézségi szintje meghaladja a fő láncét. A következő részben (<<forks>>) látni fogjuk, hogy hogyan jönnek létre másodlagos láncok, ha két bányász majdnem egyidőben azonos magasságban lévő blokkokat bányász ki. 
    
Egy új blokk beérkezése után a csomópont megpróbálja beilleszteni a blokkot a létező blokkláncba. A csomópont megvizsgálja a blokk „előző blokk hash-e” mezőjét, amely a blokk szülőjére hivatkozik. Ezután a csomópont a létező blokkláncban megpróbálja megkeresni ezt a szülőt. A legtöbbször a szülő a fő lánc „csúcsán” lesz, vagyis az új blokk a fő láncot fogja meghosszabbítani. Például a 277'316-ik blokk a 277'315-ik, szülő blokk blokk hash-ére hivatkozik. A legtöbb csomópont a 277'316-ik blokkk megérkezésekor már rendelkezik a 277'315-ik blokkal, és a 277'315-ik blokk van a fő láncuk legtetején, vagyis az új blokk beláncolása ezt a láncot fogja kibővíteni. 

Néha, amint azt a  <<forks>> részben látni fogjuk, az új blokk nem a fő láncot bővíti ki. Ebben az esetben a csomópont a másodlagos lánchoz kapcsolja hozzá az új blokkot, és azután összehasonlítja a másodlagos lánc és a fő lánc nehézségi szintjét. Ha a másodlagos lánc összegzett nehézsége nagyobb, mint a fő láncé, akkor a csomópont _átkonvergál_ a másodlagos láncra, ami azt jelenti, hogy a másodlagos láncából fő lánc válik, a korábbi fő láncából pedig másodlagos lánc. Ha a csomópont bányász csomópont, akkor az általa létrehozott blokk ezt az új „hosszabb” láncot fogja bővíteni.

Ha egy olyan érvényes blokk érkezik, melynek a létező láncban nincs szülője, akkor a blokkot a csomópont „árvának” tekinti. Az árva blokkokat az árva blokkok készletébe helyezi, és a blokk egészen addig itt fog maradni, amíg meg nem érkezik a szüleje. Ha megérkezett a szülő, és a csomópont beillesztette a szülőt a létező blokkláncba, akkor az árva blokkot kiveszi az árva blokkok készletéből, és összekapcsolja a szülőjével, vagyis a lánc részévé teszi. Árva blokkok általában akkor fordulnak elő, ha egymás után kis időeltéréssel két blokk kerül kibányászásra, és a blokkok fordított sorrendben érkeznek meg (a gyermek előbb, mint a szülő). 

A legnagyobb nehézségű lánc kiválasztása révén az összes csomópont előbb-utóbb egyezségre jut. A láncok közötti átmeneti eltéréseket végül a további mukabizonyíték hozzáadása oldja fel, amely bővíti valamelyik lehetséges láncot. A bányász csomópontok a következő blokk kibányászásakor a számítási kapacitásukkal „szavaznak”, mert ők választják ki, hogy melyik láncot akarják bővíteni. Ha sikerül kibányászniuk egy új blokkot, és kibővíteni vele a láncot, akkor maga az új blokk jelenti a szavazatukat. 

A következő részben megnézzük, hogy az egymással versenyző láncok közötti eltéréseket (elágazásokat) hogyan oldja föl az, hogy az egyes csomópontok egymástól függetlenül a legnagyobb nehézségű láncot választják.

[[forks]]
==== Blokklánc elágazások

((("blokkláncok","elágazásai", id="ix_ch08-asciidoc22", range="startofrange")))Mivel a blokklánc egy decentralizált adatszerkezet, a különböző példányai nem mindig konzisztensek. Az egyes csomópontokhoz a blokkok eltérő időben jutnak el, emiatt a csomópontok máshogy fogják látni a blokkláncot. Ennek feloldása érdekében mindegyik csomópont mindig azt a láncot választja és bővíti, amely a legtöbb munkabizonyítéknak felel meg, vagyis a legnagyobb összegzett nehézségi szinttel rendelkező láncot. A lánc blokkjaiban lévő mehézségi szint összegzése révén a csomópont kiszámítja, hogy az adott láncnak a létrehozásához összesen mennyi munkabizonyítékra volt szükség. Ha a hálózat mindegyik csomópontja a legnagyobb összegzett nehézségű láncot választja, a globális bitcoin hálózat előbb-utóbb konzisztens állapotba kerül. Az elágazások csupán átmeneti inkonzisztenciát jelentenek a blokklánc különféle változatai között. Az elágazások az átkonvergálás révén oldódnak meg, vagyis azáltal, hogy valamelyik elágazás újabb blokkokkal bővül.

A következő néhány ábrán egy „elágazási” eseményt követünk nyomon a hálózatban. Az ábra a globális bitcoin hálózat egy egyszerűsített ábrázolása. A valóságban a bitcoin hálózat nem földrajzi szerveződésű, hanem egymással kapcsolatban lévő csomópontok hálózata, melyek földzrajzilag nagyon távol is lehetnek egymástól. A földrajzi topólógia egy egyszerűsítés, amelyet az elágazás szemléltetése érdekében használunk. A valódi bitcoin hálózatban a csomópontok közötti „távolságot” a csomópontok közötti „ugrásokkal” („hops”) mérjük, nem pedig a földrajzi helyzet alapján. A szemléltetés kedvéért a különböző blokkokat különböző színekkel jelöltük.

Az lenti első ábrán (<<fork1>>) a hálózat a blokkláncot egységesnek látja. A kék blokkok a fő lánc legtetején vannak. 

[[fork1]]
.Egy blokklánc elágazás szemléltetése – az elágazás előtti állapot
image::images/msbt_0802.png["globalfork1"]

„Elágazás” akkor forul elő, ha két blokkjelölt versenyez egymással, hogy melyik van a leghosszabb blokkláncon. Normális körülmények között ez akkor fordul elő, ha két bányász egymáshoz képest viszonylag kis időkülönbséggel egy-egy új blokkot állított elő. Mindkét bányász azonnal közvetíti a „nyerő” blokkot, mihelyt sikerült megoldania a munkabizonyíték algoritmust, és a blokkok a közvetlen szomszédaikon keresztül kezdenek szétterjedni a hálózatban. Mindegyik csomópont, amelyik megkapja az érvényes blokkot, beépíti azt a blokkláncába, vagyis bővíti a saját blokkláncát egy blokkal. Ha a csomópont később egy másik blokkot lát, amely ugyanazt a szülőt bővíti, akkor a második blokkot egy másodlagos láncra helyezi. Ennek eredményeképpen bizonyos csomópontok az egyik blokkot fogják „látni” először, míg a többiek a másikat, és a blokklánc két egymással versengő változata jön létre. 

A <<fork2>> ábrán két bányászt látunk, akik majdnem egyidőben két különböző blokkot bányásztak ki. Mindkét kibányászott blokk a kék blokk gyermeke, vagyis a láncot a kék blokk tetején bővíti. Hogy az események jobban nyomon követhetők legyenek, az egyik blokkot egy Kanadából származó piros blokként ábrázoltuk, míg a másikat egy Ausztráliából származó zöld blokként. 

Tegyük fel például, hogy a kanadai bányász a „piros” blokkhoz talált egy olyan munkabizonyítékot, amely a „kék” szülő blokkláncra épül. Majdnem ugyanekkor egy ausztrál bányász, aki szintén a „kék” blokkot szeretné bővíteni, talál egy megoldást a „zöld” blokkjához. Két lehetséges blokkunk van tehát, a „piros”, ami Kanadából indul, és a „zöld”, ami Ausztráliából. Mindkét blokk érvényes, mindkét blokk érvényes munkabizonyítékot tartalmaz, mindkettő ugyanazt a szülőt bővíti. Valószínűleg mindkét blokkban ugyanazok a tranzakciók vannak, de a tranzakciók sorrendjében előfordulhatnak különbségek. 

[[fork2]]
.Egy blokklánc elágazás szemléltetése – egyszerre két blokk jött létre 
image::images/msbt_0803.png["globalfork2"]

A két blokk szétterjedése során némelyik csomóponthoz a „piros” blokk jut el először, míg másokhoz a „zöld”. Amint az a <<fork3>> mutatja, a hálózat két részre szakad, és mindkét rész másképpen látja a blokkláncot: az egyiknél a piros blokk van a blokklánc tetején, a másiknál a zöld. 

[[fork3]]
.Egy blokklánc elágazás szemléltetése – a két blokk szétterjedése során a hálózat két részre szakad
image::images/msbt_0804.png["globalfork3"]

Ettől a pillanattól kezdve a bitcoin hálózat azon csomópontjai, melyek a kanadai csomóponthoz vannak topólógiailag a legközelebb, a „piros” blokkról fognak először tudomást szerezni, és a legnagyobb nehézségi szint összeggel rendelkező láncba a „piros” blokkot teszik be a lánc utolsó tagjaként (kék-piros), a „zöld” blokkot pedig, amely egy kicsit később érkezik, figyelmen kívül hagyják. Közben az ausztráliai csomóponthoz közelebb lévő csomópontok a „zöld” blokkot fogják nyertesenk tekinteni, és ezzel bővítik a blokkláncukat (kék-zöld), és elhanyagolják a néhány másodperccel ezután megérkező „pirosat”. Azok a bányászok, melyek a „pirosat” látták meg először, olyan blokk jelölteket hoznak létre, melyekben a „piros” a szülő blokk, és ezekkel a blokkokal kezdik el a munkabizonyíték algoritmus megoldását. A „zöld” blokkot elfogadó bányászok viszont a „zöldre” épülő blokkal próbálják meg az új blokk létrehozását. 

Az elágazások majdnem mindig egy blokkon belül megoldódnak. A hálózat hash kapacitásának egyik része a „piros” blokkra épülő blokkot szeretne létrehozni, a másik része a „zöldre” épülőt. Még ha a hash kapacitás közel egyforma lenne is, akkor is valószínűtlen, hogy a két bányászcsoport ismét közel egyszerre talál egy-egy megoldást. Ha valamelyik csoport talál egy megoldást, az ezúttal zavartalanul szétterjed a hálózatban, mielőtt amásik csoport találna egy megoldást. Mondjuk, hogy azok a bányászok, akik a „zöld” blokkra építettek, találtak egy „rózsaszín” új blokkot, amely ezt a láncot bőviti ki (vagyis kék-zöld-rózsaszín). Azonnal továbbítják a blokkot a többi csomópontnak, és a blokkot az egész hálózat érvényes megoldásnak látja, amint azt a <<fork4>> mutatja. 

[[fork4]]
.Egy blokklánc elágazás szemléltetése – az elágazás egy újabb blokkal bővül
image::images/msbt_0805.png["globalfork4"]

Azok a csomópontok, melyek az előző körben a „zöldet” tekinettték győztesnek, egyszerűen kibővítik a blokkláncukat egy blokkal. Azok a csomópontok azonban, melyek a „pirosat” tekintették győztesnek, most két láncot látnak: egy kék-zöld-rózsszín láncot és egy kék-piros láncot. Ezek a csomópontok a kék-zöld-rózsaszín láncra váltanak át, és a továbbiakban ez lesz a fő lánc, a kék-piros láncot pedig másodlagos lánccá teszik, lásd a <<fork5>> ábrát. Lánc átkonvergálás történik, mivel a csomópontok egy részének meg kell változatnia a blokkláncról alkotott képét, hogy a hosszabb láncban lévő, új munkabizonyítékot tartalmazó blokkot be tudja építeni. Azok a bányászok, akik a kék-piros lánc bővítésén dolgoztak, most félbeszakítják ezt a munkát, mivel a blokkjuk, amelyen dolgoztak, „árvává” vált, hiszen a „piros” szülő blokk már nincs a leghosszabb láncban. A „piros” blokkban lévő tranzakciók ismét sorbaállnak, hogy bekerülhessenek a következő blokkba, mivel a blokk már nem a leghosszabb láncon van. Az egész hálózat átkonvergál a kék-zöld-rózsaszín blokkláncra, amelyben a „rószaszín” a lánc utolsó eleme. Az összes bányász olyan blokk jelölteken kezd dolgozni, amelyekben a „rózsaszín” blokkk a szülő, és a blokk a kék-zöld-rózsaszín láncot fogja bővíteni.

[[fork5]]
.Egy blokklánc elágazás szemléltetése – a hálózat átkonvergál a leghosszabb láncra
image::images/msbt_0806.png["globalfork5"]

Elméletileg lehetséges, hogy egy elágazás két blokkon keresztül tartson, ha a hálózat két ellentétes „végén” két bányász majdnem egyszerre két blokkot talál. Ennek a bekövetkezési valószínűsége nagyon kicsi. Míg egy blokkos elágazások hetente előfordulnak, a két blokkos elágazások nagyon ritkák.

A bitcoin 10 perces blokkideje tervezési kompromisszum a gyors megerősítési idő (tranzakciók elszámolása) és az elágazások létrejötte között. A kisebb blokk idő meggyorsítaná a tranzakciók feldolgozását, de gyakrabban lennének a blokklánc elágazások, míg a nagyobb blokkidő csökkentené az elágazások számát, de lassítaná az elszámolást.(((range="endofrange", startref="ix_ch08-asciidoc22")))(((range="endofrange", startref="ix_ch08-asciidoc21")))(((range="endofrange", startref="ix_ch08-asciidoc20")))(((range="endofrange", startref="ix_ch08-asciidoc19")))(((range="endofrange", startref="ix_ch08-asciidoc18"))) 

=== Bányászat és versenyfutás a hash kapacitásban

((("verseny a hash kapacitásban", id="ix_ch08-asciidoc23", range="startofrange")))((("bányászat","hash kapacitási verseny és", id="ix_ch08-asciidoc24", range="startofrange")))((("feldolgozási kapacitás és verseny a hash kapacitásban", id="ix_ch08-asciidoc25", range="startofrange")))A bitcoin bányászatban nagy a verseny. Amióta csak létezik a bitcoin, a hash kapacitás minden évben exponenciálisan nőtt. Néhány éve a növekedés a teljes technológiaváltást tükrözte, pl. 2010-ben és 2011-ben, amikor sok bányász CPU-ról GPU-ra (Graphical Processing Unit) és FPGA-ra (Field Programmable Gate Array) állt át. 2013-ban az ASIC-ok (Application Specific Integrated Circuits) bányászati alkalmazása újabb hatalmas ugrást okozott a bányász kapacitásban, mert az SHA256 függvény közvetlenül a bányászatra specializált szilicium integrált áramköri chip-eken lett megvalósítva. Az ilyen chip-ekből összeállított első eszközöknek több kapacitása volt, mint az egész bitcoin hálózatnak 2010-ben.

A következő lista a bitcoin hálózat teljes hash kapacitását mutatja, a hálózat működésének első öt évében:

2009:: 0.5 MH/sec–8 MH/sec (16-szoros növekedés)
2010:: 8 MH/sec–116 GH/sec (14,500-szoros növekedés)
2011:: 16 GH/sec–9 TH/sec (562-szeres növekedés)
2012:: 9 TH/sec–23 TH/sec (2.5-szeres növekedés)
2013:: 23 TH/sec–10 PH/sec (450-szeres növekedés)
2014:: 10 PH/sec–150 PH/sec in August (15-szörös növekedés)

A <<network_hashing_power>> ábrán a bitcoin hálózat hash kapacitásának a növekedése látható az elmúlt két évben. Látható, hogy a bányászok közötti versengés és a bitcoin elterjedése miatt a hash kapacitás (a hálózatban végetzhető hash-ek száma másodpercenként) exponenciálisan növekedett.

[[network_hashing_power]]
.A teljes hash kapacitás az elmúlt két évben, gigahash/sec-ben
image::images/msbt_0807.png["NetworkHashingRate"]

((("nehézségi szint","hash kapacitás és")))A bitcoin bányászat hash kapacitásának nővekedésével együtt a nehézségi szint is nőtt. A <<bitcoin_difficulty>> ábrán a nehézségi szintet egy arányszám ábrázolja, amely az aktuális nehézségi szint és a minimális nehézségi szint hányadosa (a minimális nehézségi szint az első blokk nehézségi szintjének felel meg):

[[bitcoin_difficulty]]
.A bitcoin bányászat nehézsége az elmúlt két évben
image::images/msbt_0808.png["BitcoinDifficulty"]

Az elmúlt két évben az ASIC bányász chip-ekben lévő tranzisztorok egyre kisebbek és kisebbek lettek, és ma már megközelítik a gyártható legkisebb méreteket, ami jelenleg 22 nanométer (nm). Az ASIC gyártók szeretnék a CPU gyártási technológiát alkalmazni, amely 16 nm-es vonalvastagságot használ, mert a bányászat jövedelmezősége az iparágat rendkívül gyorsan hajtja előre. A bitcoin bányászatban nem várhatók további óriási ugrások, mert az iparág eljutott a leghatékonyabb eszközökig. ((("Moore szabály")))A Moore szabály azt mondja ki, hogy az elemek sűrűsége 18 havonta megduplázódik. A hálózat bányászkapacitása ugyanakkor exponenciális ütemben fog tovább nőni, mivel az egyre kisebb méretű tranzisztorok helyett most az egyre nagyobb energiahatékonyságra tevődik át a verseny. Már nem arról szól a történet, hogy mennyit lehet bányászni egy chip-pel, hanem arról, hogy hány chip helyezhető el egy épületen belül úgy, hogy a hőleadás és a tápellátás megfelelő legyen.

[[extra_nonce]]
==== Az extra nonce megoldás

((("blokk fejek","számítási kapacitás és")))((("nehézségi szint","számítási kapacitás és")))((("nehézségi szint","extra nonce megoldás és")))((("nonce","extra")))((("extra nonce megoldás az egyre növekvő nehézségi szzinteken")))((("hash verseny","extra nonce megoldások")))2012 óta a bitcoin bányászat fejlődése megoldotta a blokkfej szerkezetének egy alapvető korlátját. A bitcoin korai napjaiban úgy lehetett egy blokkot kibányászni, hogy a bányász addig növelte a nonce értékét, amíg az eredményül kapott hash értéke kisebb nem lett a célnál. A nehézségi szint annyira megnőtt, hogy a bányászok gyakran anélkül lépkedtek végig mind a 4 milliárd értéken, hogy megoldást találtak volna. Ezt azonban könnyű volt orvosolni azzal, hogy az eltelt időnek megfelelően módosították a blokk fejben lévő időbélyeget. Mivel az időbélyeg a blokk része, a változtatás lehetővé tette, hogy a bányász ismét végigpróbálja a nonce értékeit, és más eredményeket kapjon. Amikor azonban a bányász hardverek sebessége meghaladta a 4 GH/sec-et, egyre nehezebb volt ennek a módszernek az alkalmazása, mert a nonce értékek végigvizsgálásához 1 másodpercnél rövidebb időre volt szükség. Mikor az ASIC bányász berendezések kezdték megközelíteni, ill. túllépéni az 1TH/sec hash sebességet, a bányász szoftverben az érvényes blokk előállításához szükséges további nonce értékeknek kellett helyet találni. Az időbélyeg módosítható egy kicsit, de ha túlságosan előreállítják, akkor a blokk érvénytelen lesz. A blokkfejben egy új „módosíthatósági” forrásra volt szükség. A megoldás az lett, hogy a coinbase tranzakció lett az extra nonce értékek forrása. Mivel a coinbase script 2 és 100 bájt közötti adat tárolásra képes, a bányászok ezt a helyet kezdték használni extra nonce helyként, ami lehetővé tette a számukra, hogy az érvényes blokkok előállításához sokkal nagyobb értéktartományt vizsgálhassanak át a blokkfejben. A coinbase tranzakció benne van a Merkle-fában, ami azt jelenti, hogy a coinbase script bármilyen megváltoztatása esetpén a Merkle-gyökér is megváltozik. 8 bájt extra nonce és a „hagyományos” nonce 4 bájtja 2^96^ lehetőség átvizsgálását teszi lehetővé másodpercenként, az módosítása nélkül. A jövőben a bányászok először ezeket a lehetőségeket fogják kimeríteni, és csak ez után nyúlnak az időbélyeg módosításának módszeréhez. A coinbase scriptben van még további hely is, ha szükség lenne az extra nonce tér kibővítésére.

[[mining_pools]]
==== Bánytársaságok (Mining Pools)

((("hash verseny","mining pools", id="ix_ch08-asciidoc26", range="startofrange")))((("bányatársaságok", id="ix_ch08-asciidoc27", range="startofrange")))Ebben a rendkívül versengő környezetben a magányos bányászoknak (az ún. szingli bányászoknak) esélyük sincs a jutalomra. Annak a valószínűsége, hogy találnak egy blokkot, amely majd fedezi az energia és hardver költségeiket, annyira csekély, mint ha szerencsejátékot játszanának, például olyan, mint ha lottóznának. Még a kereskedelmi forgalomban lévő leggyorsabb ASIC bányász rendszerek sem tudják felvenni a versenyt azokkal a rendszerekkel, amelyek ilyen ASIC chip-ek tízezreit zsúfolják be hatalmas épületekbe, és vízerőművek olcsó energiáját használják. A bányászok ezért bányatársaságokat alkotnak, közösen bányásznak, és a jutalmat a sok ezer résztvevő között osztják el. Ha egy bányász bányatársaságban bányászik, akkor a teljes jutalomnak csak egy kis részét kapja meg, de minden nap kap valami jutalmat, ami csökkenti a bizonytalanságot.

Nézzünk egy konkrét példát. Tegyük fel, hogy egy bányász vett egy bányagépet, amelynek összkapacitása 6000 GH/sec, azaz 6 TH/sec. 2014 augusztusában egy ilyen berendezés kb. 10,000 USD-be került. A hardver fogyasztása 3 kW * 24 óra, azaz 72 kWh naponta, ami kb. napi 8 USD kiadást jelent. A jelenlegi bitcoin nehézségi szintnél a bányász szingli-módban kb. 155 naponként (5 havonta) tud kibányászni egy blokkot. Ha a bányász az 5 hónap alatt talál egy blokkot, akkor a jutalma 25 bitcoin, ami 600 $-os árfolyammal számolva kb. 15'000 USD egyszeri kifizetésnek felel meg, ami fedezi a hardver és villamos energia költségeket, és kb. 3000 USD hasznot eredményez. Az viszont, hogy talál-e a bányász 5 hónap alatt egy blokkot, a szerencsén múlik. Lehet, hogy két blokkot is talál, és nagyon nagy haszonra tesz szert. Az is lehet, hogy 10 hónap alatt sem talál egyetlen egy blokkot sem, és veszteséges lesz. Még súlyosabb, hogy a munkabizonyíték algoritmus nehézségi szintje valószínűleg jelentősen nőni fog ezen időszak alatt, figyelembe véve a hash kapacitás jelenlegi növekedését, ami azt jelenti, hogy a bányásznak max. 6 hónapja van arra, hogy nullszaldót érjen el, mert ez alatt a hardvere gyakorlatilag elavul, és egy nagyobb kapacitású, hatékonyabb hardvert kell beszereznie. Ha azonban a bányász egy bányatársaságban vesz részt, akkor nem kell az 5 havonkénti egyszeri, 15'000 dolláros alkalomra várnia, hanem heti 500 és 750 dollár közötti összeget fog keresni. A bányatársaság kifizetései révén amortizálni tudja a hardverköltséget és ki tudja fizetni a villamos energiát anélkül, hogy hatalmas kockázatot vállalna. A hardver 6 – 9 hónap múlva még mindig elavul, és a kockázat még mindig magas, de a vizsgált időszak alatt a bevétel kiszámítható és biztos.

A bányatársaságok speciális protokollok segítségével több száz ill. több ezer bányász munkáját hangolják össze. Az egyes bányászok egy számlaszámot nyitnak a bányatársaság szerverén, majd ezt követően úgy állítják be a berendezéseiket, hogy azok ehhez a szerverhez kapcsolódjanak. A bányászok a bányászat során a hardverükkel ehhez a szerverhez kapcsolódnak, a szerver pedig összehangolja a munkájukat a többi bányászéval. Ez azt jelenti, hogy a bányatársaság tagjai közösen bányásznak ki egy blokkot, és osztoznak a jutalomban. 

Egy blokk sikeres kibányászásakor a jutalom nem az egyes bányászokhoz, hanem a bányatársaság bitcoin címére kerül. A szerver bizonyos időközönként, ha a jutalom meghalad egy bizonyos határt, kifizeti a bányászokat. A bányatársaság általában egy pár százalákos díjat számít fel a szolgáltatásáért.

A bányatársaságban részt vevő bányászok megosztják egymás között a következő blokk utáni kutatómunkát, és „részvényeket” kapnak a munkájukért. A bányatársaságon belül beállított nehézségi szint általában 1000-szer kisebb, mint a bitcoin hálózat aktuális nehézségi szintje. Ha egy bányász talál egy blokkot, amely megfelel ennek a kisebb nehézségi szintnek, akkor kap egy részvényt. Ha valamelyik bányász sikerrel jár, és kibányász egy blokkot, akkor a jutalom a bányatársasághoz került, és a bányászok között annak arányában kerül felosztásra, hogy ki hány részvénnyel járult hozzá a munkához. 

A bányatársaságok bárki előtt nyitva állnak, legyen profi vagy amatőr, óriási vagy pirinyó hash kapacitással. A bányatársaságoknak egyes tagjainak csak egy kis teljesítményű kütyüje van, míg mások egy teli garázs nagy teljesítményű készülékkel rendelkeznek. Némelyik bányász berendezéseinek pár kilowatt a fogyasztása, míg mások egy egész adatközponttal bányászkodnak, melynek pár megawatt a fogyasztása. Hogyan tudja a bányatársaság lemérni, hogy ki mennyivel járul hozzá a közös munkához, hogyan tudja megakadályozni, hogy a bányászok csaljanak? A választ a bitcoin munkabizonyíték rendszere jelenti, amely alacsonyabb nehézségi szintre van beállítva. Ennél az alacsonyabb nehézségi szintnél még a legkisebb hash kapacitással rendelkező bányász is elég gyakran jut részvényekhez, és emiatt megérni neki, hogy részt vegyen a bányatársaság munkájában. Azzal, hogy a bányatársaság alacsonyabbra állítja be a részvényhez jutás nehézségi szintjét, a mérni tudja az egyes bányászok által elvégzett munka nagyságát. Ha valamelyik bányász talál egy olyan blokkfej hash értéket, amely kisebb a bányatársaság által megszabott nezézségi szintnél, akkor ezzel bizonyítani tudja, hogy elvégezte a munkát, ami ennek a hash-nek az előállításához kellett. De ami ennél is fontosabb, a részvények keresése statisztikailag is mérhető formában hozzájárul ahhoz a munkához, amely a hálózati küszöbértéknél kisebb hash-ű blokk előállítására irányul. A bányászok ezrei közül, akik minél kisebb hash-eket próbálnak előállítani, egynek végül sikerülni fog egy olyan hash-t találni, amely elég kicsiny ahhoz, hogy kielégítse a bitcoin hálózat által felállított célt. 

Térjünk vissza a kockajáték hasonlathoz. Ha a játéknak az a célja, hogy négynél kevesebbet dobjunk (a teljes hálózatra vonatkozó cél), akkor a bányatársaság egy könnyebb célt ad meg, és pl. megszámolja, hogy hányszor sikerült a bányatársaságban részt vevő játékosoknak 8-nál kevesebbet dobnia. Ha egy játékos 8-nál kevesebbet dob (a bányatársaság által felállított cél), akkor a játékos kap egy részvényt, de nem nyeri meg a játékot, mivel a játék még nem érte el a célját (hogy az összeg 4-nél kevesebb legyen). A társaságban lévő játékosok a könnyebb célt gyakrabban elérik, és szabályosabb időközönként jutnak részvényekhez, még ha nem is érik el a nehezebb célt, a játék megnyerését. Néha valamelyik játékosnak sikerül olyat dobni, hogy a kockák összege négynél kevesebb legyen, vagyis megnyeri a játékot a társaságnak. Ekkor a bevétel a játékosok között annak az arányában osztható el, hogy ki hány részvénnyel rendelkezik. A 8-nál kisebb cél ugyan nem volt nyerő, de jól mérte a játékban résztvevő játékosok kockadobásainak a számát. 

Hasonlóléppen, a bányatársaság  által beállított nehézségi szint esetén az egyes bányászok gyakran találnak olyan blokkfejeket, amelyek hash értéke kisebb ennél, és így részvényekhez jutnak. Néha egy olyan blokkfej áll elő amelynek hash-e kisebb a bitcoin hálózat által megkövetelt célnál, vagyis a blokk érvényes lesz, és az egész társaság nyer.(((range="endofrange", startref="ix_ch08-asciidoc27")))(((range="endofrange", startref="ix_ch08-asciidoc26"))) 

==== Felügyelt bányatársaságok (Managed pools)

((("felügyelt bányatársaságok")))((("bányatársaságok","felügyelt ~ ")))A legtöbb bányatársaság „felügyelt”, ami azt jelenti, hogy van egy egyén vagy szervezet, aki/amely a bányatársaság szerverét, a pool szervert futtatja. A szerver tulajdonosát _pool operátornak_ hívják, és a bányászoktól a bevételből pár százalékos díjat szed. 

A pool szerver speciális szoftvert és pool bányászprotokolt futtat, amely összehangolja a bányászok tevékenységét. A pool szerver egy vagy több teljes csomóponthoz is kapcsolódik, és közvetlen hozzáférése van a teljes blokklánc adatbázishoz. Ez lehetővé teszi, hogy a pool szerver a bányászok nevében ellenőrizze a tranzakciókat és a blokkokat, és mentesítse őket a teljes csomópont futtatásának terhétől. A bányászok szempontjából ez nagyon fontos szempont, mivel egy teljes csomóponthoz egy külön számítógépre van szükség, melynek legalább 15 – 20 Gbájtos tárolója (diszk) és legalább 2 Gbájt memóriája (RAM) van. Ez kívül a teljes csomópontokon futó bitcoin szoftver monitorozást igényel, karban kell tartani és gyakran kell verzióváltást végezni. Bármilyen leállás, amit a karbantartás hiánya vagy erőforrás hiány okoz, hátrányosan érinti a bányászok profitját. Sok bányász amiatt csatlakozik egy felügyelt bányatársasághoz, mert nagy előnyt jelent, hogy egy teljes csomópont futtatása nélkül is bányászkodni tud. 

A bányatársaság bányászai egy bányász protokoll segítségével kapcsolódnak a pool szerverhez, pl. ((("Stratum (STM) bányász protokoll"))) Stratum (STM) vagy ((("GetBlockTemplate (GBT) bányász protokoll")))GetBlockTemplate (GBT) segítségével. Egy régebbi szabvány, melynek ((("GetWork (GWK) bányász protokoll")))GetWork a neve, 2012 vége óta elavultnak számít, mivel 4 GH/s felett nehézkesen támogatja a bányászatot. Mind az STM, mind a GBT protokoll ((("blokk sablonok")))_blokk sablonokat_ hoz létre, amelyek a létrehozandó blokk blokkfejének sablonját tartalmazzák. A pool szerver a tranzakciók összesítésével előállítja a létrehozandó blokk jelöltet, beleteszi a coinbase tranzakciót (az extra nonce hellyel), kiszámítja a Merkle-gyökeret, és hozzákapcsolja az előző blokk hash-ét. Az előállítandó blokk jelölt fejét ezután sablonként elküldi a pool bányászainak. Mindegyik bányász ezt a sablont használja, persze kisebb nehézségi szinttel, mint ami a bitcoin hálózatban fennáll, és a sikeres eredményeket visszaküldi a pool szervernek, hogy részvényeket kaphasson. 

===== P2Pool

((("bányatársaságok","P2Pool")))((("P2Pool")))A felügyelt pool-ok megteremtik a lehetőségét annak, hogy a pool operátor csaljon, hiszen az operátor a tagok által végzett munkát arra használhatja, hogy kettős költést kíséreljen meg, vagy hogy érvénytelenné tegyen egy blokkot (lásd <<consensus_attacks>>). Ezen kívül a központosított pool szerverek egy egy-pontos meghibásodási lehetőséget jelentenek. Ha a pool szerver leáll, vagy DoS támadás éri, akkor a pool bányászai nem tudnak tovább bányászni. 2011-ben ezen kérdések megoldására egy új bányászati módszert javasoltak és fejlesztettek ki: a P2Pool egy peer-to-peer bányász protokoll, melynek nincs operátora. 
    
A P2Pool decentralizálja a pool szerver feladatait oly módon, hogy egy párhuzamos, blokklánc-szerű rendszert valósít meg, az ún. ((("részvénylánc")))_részvényláncot_ (sharechain-t) . A részvénylánc a bitcoin blokkláncnál alacsonyabb nehézségi szinttel rendelkező lánc. A részvénylánc lehetővé teszi a bányászok decentralizált poolban történő együttműködését, mert a részvényláncon 30 másodpercenként áll elő egy részvényeknek megfelelő blokk. A részvénylánc minden egyes blokkja rögzíti a munkában résztvevő bányászok arányos jutalmait, és az előző részvényblokkból tovább viszi az addigi eredményeket. Ha valamelyik részvényblokk eléri a bitcoin hálózat nehézségi szintjét, akkor továbbításra kerül a bitcoin hálózatba és bekerül a blokkláncba. A jutalmat azok a bányászok kapják, akik létrehozták a nyerő blokk előtti részvényeket. Lényegében ahelyett, hogy egy pool szerver tartaná nyilván a pool bányászainak részvényeit és jutalmát, a részvénylánc biztosítja a bányászok számára, hogy a bitcoin blokklánc konszenzus mechanizmusához hasonló, decentralizált konszenzus mechanizmus segítségével tartsák nyilván a részvényeket. 

A P2Pool bányászat bonyolultabb, mint a bányatársaságokban történő bányászat, mivel a P2Pool bányászathoz egy külön számítógépre van szükség, amelyen elégséges a diszk hely, a memória, és az internet sávszélesség ahhoz, hogy támogatni tudjon egy teljes bitcoin csomópontot valamint a P2Pool csomópont szoftverét. A P2Pool bányászok a bányagépeiket a helyi P2Pool csomópontjukkal kötik össze, ami egy pool szerver funkcióit szimulálja, vagyis blokk sablonokat küld a bányász hardvernek. Egy P2Pool-ban mindegyik bányász maga állítja össze a blokk jelöltjét, és a tranzakciókból épp úgy képzi a blokkot, mint a szingli bányászok, de ezt követően a részvény láncon közösen bányászik a többi bányásszal . A P2Pool egy hibrid módszer, amelynek előnye, hogy tagjai gyakrabban jutnak jövedelemhez, mint a szingli bányászok, de mindezt anélkül valósul meg, hogy egy pool operátor túl sok felügyeleti joghoz jutna. 

Mostanában a P2Pool-okban jelentősen nőtt a részvétel, mivel a bányatársaságok koncentrációja megközelítette azt a szintet, ami már felveti az ((("51%-os támadás")))51%-os támadással kapcsolatos aggodalmakat (lásd <<consensus_attacks>>). A P2Pool protokoll továbbbfejlesztése várhatóan szükségtelenné teszi majd a teljes csomópont futtatását, ami még könnyebbé teszi majd a decentralizált bányászatot.(((range="endofrange", startref="ix_ch08-asciidoc25")))(((range="endofrange", startref="ix_ch08-asciidoc24")))(((range="endofrange", startref="ix_ch08-asciidoc23"))) 

Noha a P2Pool csökkenti a bányatársaságok operátorainak a hatalmát, maga a részvénylánc viszont sebezhető az 51%-os támadásokkal szemben. A P2Pool sokkal szélesebb elterjedése sem oldja meg a bitcoin 51%-os támadásokkal kapcsolatos problémáját.  A P2Pool inkább csak ellenállóbbá teszi a teljes rendszert, mert diverzifikálja a bányászati ökoszisztémát. 

[[consensus_attacks]]
=== A konszenzus elleni támadások

((("konszenzus","támadások ellene", id="ix_ch08-asciidoc28", range="startofrange")))((("biztonság","konszenzus elleni támadások", id="ix_ch08-asciidoc29", range="startofrange")))A bitcoin konszenzus mechanizmusa elméletben támadható, ha a bányászok (vagy pool-ok) a hash kapacitásaikat tisztességtelen vagy ártalmas célra használják. Mint láttuk, a konszenzus mechanizmus azon alapul, hogy a bányászok többsége becsületesen, önzetlenül viselkedik. De ha egy bányásznak vagy egy bányász csoportnak sikerül megszereznie a bányász kapacitás jelentős részét, akkor a konszenzus mechanizmus ellen indított támadással szétzilálhatja a bitcoin hálózat biztonságát és rendelkezésre állását. 

Fontos megjegyeznünk, hogy konszenzus elleni támadásokkal csak a jövőbeli, vagy legfeljebb a közelmúlt eseményei befolyásolhatók (néhányszor tíz blokk). A bitcoin főkönyve az idő múlásával egyre ellenállóbb. Bizonyos „mélységen” túl a blokkok teljesen immunisak, még egy olyan tartós, konszenzus elleni támadás esetén is, amely elágazást hoz létre. A konszenzus elleni támadások nem érintik a titkos kulcsok és az aláíró algoritmus (ECDSA) biztonságát. Egy konszenzus elleni támadással nem lehet bitcoinokat lopni, vagy aláírás nélkül bitcoinokat elkölteni, átirányítani őkat vagy más módon megváltoztatni a régebbi tranzakciókat vagy bejegyzéseket. A konszenzus elleni támadások csak a legutóbbi blokkokat érintik, és megakadályhatják további blokkok előállítását, vagyis DoS (denial-of-service, szolgáltatás megtagadási) támadást valósíthatnak meg. 

((("51%-os támadás")))((("konszenzus elleni támadás","51%-os támadás")))A konszenzus mechanizmus elleni egyik ilyen támadás forgatókönyve az ún. „51 %-os támadás”. Ennél a forgatókönyvnél a hálózat hash kapacitás többségével (51%-val) rendelkező bányászok összejátszanak egymással. Mivel a támadók képesek arra, hogy a blokkok többségét ők bányásszák ki, ezért tudatosan „elágazásokat” képesek létrehozni a blokkláncban, és kétszer is el tudják költeni ugyanazt a bitcoint, vagy DoS támadást képesek indítani bizonyos tranzakciók vagy címek ellen. ((("kétszeres költés, mint támadás")))((("elágazás, mint támadás")))Egy elágazás/készeres költés úgy valósul meg, hogy a támadó az előzőleg már megerősített blokkokat érvénytelenné teszi, mégpedig úgy, hogy a blokkok előtt egy elágazást hoz létre, és egy alternatív láncra történő átkonvergálást kényszerít ki. Megfelelő hash kapacitással a támadó egymás után akár 6 vagy még több blokkot érvénytelenné tud tenni, ezáltal azok a tranzakciók, amelyeket már változatlannak tekintettek (6 megerősítés), érvénytelenné válnak. Megjegyzem, hogy a kettős költés csak a támadó saját tranzakcióinál valósítható meg, mert a támadó ezeket tudja szabályosan aláírni. A saját tranzakciók újbóli elköltése akkor rentábilis, ha a támadó így egy visszafordíthatatlan kifizetéshez vagy áruhoz jut, anélkül, hogy fizetne érte. 

Nézzünk az 51 %-os támadásra egy gyakorlati példát. Az első fejezetben láttunk egy Alice és Bob közötti tranzakciót, amellyel Alice vett egy csésze kávét. Bob, a kávéház tulajdonosa szívesen elfogadja a kávé árát anélkül is, hogy megvárná a megerősítését (egy blokk kibányászását), mert a kettős költés veszélye egy csésze kávé esetén viszonylag csekély, és fontosabb a gyors kiszolgálás. Ez hasonló ahhoz a gyakorlathoz, hogy a legtöbb kávéházban 25 $ alatti összegeknél a hitlekártyás fizetési módot aláírás nélkül is elfogadják, mivel az utólagos visszaszámlázás veszélye kicsi, míg az aláírás okozta késedelem költsége viszonylag nagy. Ezzel szemben ha egy költségesebb tételt adnak el bitcoinért, akkor a kettős költés veszélye nagyobb, mivel a vevő szétküldhet egy másik tranzakciót, amely ugyanazokat a bemeneteket (UTXO) költi el, és a kereskedő hoppon marad. Kettős költés kétféleképpen valósulhat meg: vagy úgy, hogy a tranzakció még nincs megerősítve, vagy úgy, hogy a támadó egy blokklánc elágazás segítségével számos blokkot „visszacsinál”. Egy 51 %-os támadás esetén a támadó egy új láncon másodszor is képes elkölteni a saját tranzakcióiban lévő bitcoinokat, és így érvényteleníteni tudja a régi lánc ezeknek megfelelő tranzakcióit. 

Példákban a rosszindulatú támadó, Mallory elmegy Carol galériájába, és vásárol egy gyönyörű szárnyas oltárt, amely Satoshi Nakamotót Prométeuszként ábrázolja. Carol „A nagy tűz” című képet, mely 250'000$-ba kerül, bitcoinért adja el Malllory-nak. Carol ahelyett, hogy várna hat vagy hét megerősítésre, becsomagolja a képet, és egy megerősítés után átadja Mallory-nak. Mallory bűntársa, Paul egy nagy bányatársaságot üzemeltet. Amint Mallory tranzakciója bekerül a blokkláncba, Paul azonnal indít egy 51%-os támadást. Paul úgy befolyásolja a bányatársaság munkáját, hogy ugyanazon a blokkmagasságon, amelyen a Mallory tranzakcióját tartalmazó blokk van, újrabányásszanak egy blokkot. A régi blokkot az új blokk fogja helyettesíteni, és Mallory Carol-nak történő fizetsége helyett egy olyan tranzakciót fog tartalmazni, amely ugyanazokat a bemeneteket költi el, de ezúttal Mallory számára. A másodszori költéshez tartozó tranzakció ugyanazokat az UTXO-kat fogyasztja el, és Mallory pénztárcájába fizeti vissza őket, vagyis Mallory ahelyett hogy fizetne, lényegében megtartja a bitcoinokat. Paul ezután egy újabb blokkot állíttat elő a bányatársasággal, hogy a kettős költést tartalmazó lánc hosszabb legyen, mint az eredeti lánc (vagyis egy elágazást okoz a Mallory tranzakcióját tartalmazó blokk alatt). Ha a blokklánc elágazás az új (hosszabb) lánc javára dől el, akkor a második tranzakció fog az eredeti, Carolnak történő fizetség helyébe lépni. Carol ott áll fizetség és szárnyas oltár nélkül. Azok a bányászok, akik Paul bányatársaságában dolgoznak, egyálatlán nem tudnak a kettős költési kísérletről, mivel a bányászat automatizált, és nem tudnak minden tranzakciót vagy blokkot nyomon követni.

Ha egy kereskedő védekezni szeretne az efféle támadások ellen, akkor nagy értékű tételek esetén várnia kell legalább hat megerősítésre, mielőtt a terméket odaadná a vevőnek. Egy másik lehetőség, ha az eladó egy több aláírást megkívánó (multisig) letéti számlát használ, és a pénz beérkezése után ismét csak jó néhány megerősítést megvár. Minél több a megerősítés, annál nehezebb a tranzakciót egy 51 %-os támadással érvénytelenné tenni. A nagy értékű tételeknél bitcoinnal fizetni még mindig kényelmes és hatékony, még akkor is, ha a vevőnek 24 órát kell várnia a szállításra, ami 144 megerősítést jelent. 

((("konszenzus támadások","DoS támadás")))((("DoS támadás")))A kettős költésen kívül van egy másik forgatókönyv, amelynél a konszenzus elleni támadással bizonyos bitcoin szereplők (adott bitcoin címek) működése hiusítható meg. Az a támadó, aki rendelkezik a többségi bányász kapacitással, egyszerűen figyelmen kívül hagy bizonyos tranzakciókat. Ha ezek a tranzakciók bekerültek egy másik bányász által előállított blokkba, akkor a támadó szándékosan elágazást hoz létre, és újrabányássza a blokkot, ezáltal ismét meghiusítja a tranzakciót. Ezzel a támadással tartós szolgáltatás megtagadás (DoS) érhető el egy adott címmel vagy címekkel szemben, ha a támadó rendelkezik a bányász kapacitás többségével. 

A neve ellenére az 51 %-os támadáshoz nem szükséges, hogy a támadó ténylegesen rendelkezzen a hash kapacitás 51%-ával. Egy ilyen támadás már kisebb kapacitásnál is megkísérelhető. Az 51%-os határ egyszerűen csak azt a szintet jelzi, amelynél az ilyen támadás majdnem mindig sikeres lesz. A konszenzus elleni támadás lényegében a következő blokkért folytatott kötélhúzás, melyben valószínűleg az „erősebb” csoport győz. Kevesebb hash kapacitásnál a siker valószínűsége is kisebb, mivel a többi bányász a blokkok előállítását „becsületes” módon végzi. Úgy is lehet nézni a dolgot, hogy minél több hash kapacitása van a támadónak, annál hosszabb elágazást tud szándékosan létrehozni, vagyis annál több, a közelmúltban létrejött blokkot tud érvényteleníteni, vagy annál több jövőbeli blokkot tud befolyásolni. Biztonsági kutatók statisztikai modellezéssel megállapították, hogy különféle konszenzus elleni támadások már akár 30 %-os hash kapacitás esetén is lehetségesek. 

A teljes hash kapacitás nagy mértű növekedése a bitcoint vitathatatlanul támadhatatlanná tette az egyes bányászokkal szemben. Egy szingli ványász még a teljes hálózati kapacitás 1 %-a felett sem rendelkezik. Ugyanakkor a bányatársaságok miatt megjelenő központosítás magával hozta annak a veszélyét, hogy a pool operátora hasznonszerzési céllal támadást indít. A felügyelt pool-ok operátora képes az előállítandó blokkok befolyásolásásra, és képes azt is eldönteni, hogy mely tranzakciók kerüljenek be a blokkba. Ha a pool operátora korlátozott mértékben és ügyesen él vissza ezzel az erővel, akkor anélkül profitálhat egy konszenzus elleni támadásból, hogy lebukna.

Vannak olyan támadók is, akiket nem a haszonszerzés vágya hajt. Az egyik ilyen lehetséges forgatókönyvben a támadó célja a bitcoin hálózat szétzilálása, anélkül, hogy profitálna ebből a bomlasztásból. A bitcoin hálózat megbénításához hihetetlen nagy befektetésre és titkos tervekre van szükség, de egy nagy költségvetésű, véhetően valamelyik kormány által finanszírozott támadó még erre is képes lehet. Az is elképzelhető, hogy egy pénzes támadó egyszerre többféle módon ássa alá a konszenzus mechanizmust: bányász hardvert halmoz fel, megvesztegeti a pool operátotokat, és DoS támadást indít a többi pool ellen. Elméletileg mindegyik forgatókönyv lehetséges, de a bitcoin hash kapacitásának exponenciális növekedése mellett ez az út egyre kevésbé jártható. 

Kétségtelen tény, hogy egy konszenzus elleni komoly támadás megingatná a bitcoinba vetett rövid távú bizalmat, és jelentős árcsökkenéssel járna. A bitcoin hálózat és szoftver viszont állandóan fejlődik, emiatt a konszenzus elleni támadásokra a bitcoin közösség azonnal megfelelő ellenintézkedéseket tud tenni, ami a bitcoint még ellenállóbbá, egészségesébbé és robusztusabbá teszi.(((range="endofrange", startref="ix_ch08-asciidoc29")))(((range="endofrange", startref="ix_ch08-asciidoc28")))(((range="endofrange", startref="ix_ch08-asciidoc1")))(((range="endofrange", startref="ix_ch08-asciidoc0")))
